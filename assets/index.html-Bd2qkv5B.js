import{_ as a,c as o,a as d,o as p}from"./app-C7T5jqfQ.js";const c={};function t(r,e){return p(),o("div",null,e[0]||(e[0]=[d('<p>本章旨在为您提供一系列问题，您需要回答这些问题才能编写一个好的资源处理程序。它旨在作为逐步指南使用。</p><h2 id="服务" tabindex="-1"><a class="header-anchor" href="#服务"><span>服务</span></a></h2><p>服务是否可能不可用，以及在不可用时我们是否能够检测到？例如，数据库连接问题可能可以早期检测到。我们还可能计划对整个系统或其部分进行停机。请实现 <code>service_available</code> 回调。</p><p>服务实现了哪些 HTTP 方法？我们需要的标准方法包括 OPTIONS、HEAD、GET、PUT、POST、PATCH 和 DELETE 之外还需要实现其他方法吗？我们是否完全没有使用这些方法？请实现 <code>known_methods</code> 回调。</p><h2 id="资源处理器类型" tabindex="-1"><a class="header-anchor" href="#资源处理器类型"><span>资源处理器类型</span></a></h2><p>我是在为一组资源编写处理器，还是为单个资源编写处理器？</p><p>这些的语义非常不同。你不应该在同一处理器中混用集合和单个资源。</p><h2 id="收集处理器" tabindex="-1"><a class="header-anchor" href="#收集处理器"><span>收集处理器</span></a></h2><p>如果您不需要进行收集，请跳过本节。</p><p>收集是硬编码的还是动态的？例如，如果您使用路由 <code>/users</code> 来表示用户集合，那么收集是硬编码的；如果您使用 <code>/forums/:category</code> 来表示线程集合，则不是硬编码的。当收集是硬编码的时，您可以安全地假设资源始终存在。</p><p>我应该实现哪些方法？</p><p>OPTIONS 用于获取集合的一些信息。即使你不实现它，也建议允许它，因为 Cowboy 内置了一个默认实现。</p><p>HEAD 和 GET 用于检索集合。如果你允许 GET，也允许 HEAD，因为不需要额外的工作来使其工作。</p><p>POST 用于在集合内部创建新的资源。当资源可能在知道其 URI 之前创建时，使用集合上的 POST 创建资源是有用的，通常是因为其中的一部分是动态生成的。一个常见的例子是某种自动递增的整数标识符。</p><p>下一个方法更少被允许。</p><p>PUT 用于创建一个新的集合（当集合未硬编码时），或替换整个集合。</p><p>DELETE 用于删除整个集合。</p><p>PATCH 用于使用请求体中的指令修改集合。PATCH 操作是原子性的。可以使用 PATCH 操作对集合进行排序；添加、修改或删除集合的部分内容。</p><h2 id="单个资源处理器" tabindex="-1"><a class="header-anchor" href="#单个资源处理器"><span>单个资源处理器</span></a></h2><p>如果您正在做数据收集，请跳过这一部分。</p><p>我应该实现哪些方法？</p><p>OPTIONS 用于获取一些关于资源的信息。即使您不实现它，也建议允许它，因为 Cowboy 有一个内置的默认实现。</p><p>HEAD 和 GET 用于检索资源。如果您允许 GET，也允许 HEAD，因为不需要额外的工作。</p><p>POST 用于更新资源。</p><p>PUT 用于创建新的资源（当该资源不存在时）或替换资源。</p><p>DELETE 用于删除资源。</p><p>PATCH 用于使用请求体中的指令修改资源。PATCH 操作是原子性的。可以使用 PATCH 操作对资源进行添加、删除或修改特定值的操作。</p><h2 id="资源" tabindex="-1"><a class="header-anchor" href="#资源"><span>资源</span></a></h2><p>在上述讨论之后，实现 <code>allowed_methods</code> 回调。</p><p>资源总是存在的吗？如果不一定存在，请实现 <code>resource_exists</code> 回调。</p><p>我是否需要在客户端可以访问资源之前对其进行身份验证？应该提供哪些身份验证机制？这可能包括基于表单的、基于令牌的（在 URL 或 cookie 中）、HTTP 基本、HTTP 摘要、SSL 证书或其他任何形式的身份验证。请实现 <code>is_authorized</code> 回调。</p><p>我需要细粒度的访问控制吗？如何确定他们是否有授权访问？在你的 <code>is_authorized</code> 回调中处理这个问题。</p><p>即使资源被授权访问，访问是否也可以被禁止？一个简单的例子就是资源的审查。通过实现 <code>forbidden</code> 回调来实现。</p><p>认证用户对资源的访问是否可以进行速率限制？使用 <code>rate_limited</code> 回调。</p><p>资源 URI 的长度是否有任何限制？例如，URI 可能用作存储中的键，并且可能有长度限制。实现 <code>uri_too_long</code>。</p><h2 id="表现形式" tabindex="-1"><a class="header-anchor" href="#表现形式"><span>表现形式</span></a></h2><p>我提供了哪些媒体类型？如果是基于文本的，提供了哪些字符集？提供了哪些语言？</p><p>实现必需的 <code>content_types_provided</code>。将回调函数前缀为 <code>to_</code> 以增加清晰度。例如，<code>to_html</code> 或 <code>to_text</code>。对于不实现 GET 或 HEAD 方法的资源，您必须至少支持一种媒体类型，但可以将回调留作 <code>undefined</code>，因为它们将永远不会被调用。</p><p>如果适用，请实现 <code>languages_provided</code> 或 <code>charsets_provided</code> 回调。</p><p>资源是否接受范围请求？如果支持，实现 <code>ranges_provided</code> 回调。只接受<code>字节</code>单位的资源可以使用回调名称 <code>auto</code>，让 Cowboy 自动处理范围响应。其他回调应以 <code>ranged_</code> 为前缀以增加清晰度，例如 <code>ranged_bytes</code> 或 <code>ranged_pages</code>。如果资源在同意进行范围响应之前需要进行额外检查，请实现 <code>range_satisfiable</code> 回调。</p><p>是否有其他头信息可能会影响资源的表现形式？实现 <code>variances</code> 回调。</p><p>根据内容缓存的选择，您可能需要实现一个或多个 <code>generate_etag</code>、<code>last_modified</code> 和 <code>expires</code> 回调。</p><p>我是否希望用户或用户代理主动选择可用的表示形式？在响应主体中发送可用表示形式的列表并实现 <code>multiple_choices</code> 回调。</p><h2 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向"><span>重定向</span></a></h2><p>我需要跟踪哪些资源被删除了吗？例如，你可能有一个机制，当移动资源时会留下指向新位置的重定向链接。实现 <code>previously_existed</code> 回调。</p><p>资源是否被移动了，而且移动是否是临时的？如果是明确的临时移动，例如由于维护，实现 <code>moved_temporarily</code> 回调。否则，实现 <code>moved_permanently</code> 回调。</p><h2 id="请求" tabindex="-1"><a class="header-anchor" href="#请求"><span>请求</span></a></h2><p>你需要读取查询字符串吗？个体头吗？实现 <code>malformed_request</code> 并在该函数中进行所有解析和验证。请注意，此时不应读取主体。</p><p>是否有请求体？我会知道它的大小吗？我愿意接受的最大请求体大小是多少？实现 <code>valid_entity_length</code>。</p><p>最后，查看你正在实现的方法对应的部分。</p><h2 id="options-方法" tabindex="-1"><a class="header-anchor" href="#options-方法"><span>OPTIONS 方法</span></a></h2><p>默认情况下，Cowboy 会返回允许的方法列表。我是否需要向响应中添加更多信息？实现 <code>options</code> 方法。</p><h2 id="get-和-head-方法" tabindex="-1"><a class="header-anchor" href="#get-和-head-方法"><span>GET 和 HEAD 方法</span></a></h2><p>如果实现了 GET 和/或 HEAD 方法，必须为 content_types_provided 回调返回的每个内容类型实现一个 ProvideCallback 回调。</p><p>如果接受范围请求，必须为 ranges_provided 回调返回的每个范围单位实现一个 RangeCallback 回调（除非使用了 auto）。这还需要额外实现一个 ProvideCallback 回调。</p><h2 id="put-post-和-patch-方法" tabindex="-1"><a class="header-anchor" href="#put-post-和-patch-方法"><span>PUT, POST 和 PATCH 方法</span></a></h2><p>如果实现了 PUT、POST 和/或 PATCH 方法，必须实现 content_types_accepted 回调，并为 content_types_accepted 回调返回的每个内容类型实现一个 AcceptCallback 回调。将 AcceptCallback 回调名称以 from_ 前缀命名以增加清晰度。例如，from_html 或 from_json。</p><p>我们希望允许通过其 URI 直接使用 POST 方法创建单个资源（类似于 PUT）吗？建议在这种情况下显式使用 PUT。实现 <code>allow_missing_post</code> 回调。</p><p>使用 PUT 创建或替换资源时会有冲突吗？我们是否希望确保在同一时间周围的两个更新不会相互抵消？实现 <code>is_conflict</code> 回调。</p><h2 id="delete-方法" tabindex="-1"><a class="header-anchor" href="#delete-方法"><span>DELETE 方法</span></a></h2><p>如果实现方法 DELETE，必须实现 <code>delete_resource</code> 回调。</p><p>当 <code>delete_resource</code> 返回时，资源是否已从服务器完全删除，包括从任何缓存服务中删除？如果没有，或者删除是异步的且我们无法确定是否已完成，则需要实现 <code>delete_completed</code> 回调。</p>',62)]))}const n=a(c,[["render",t]]),i=JSON.parse('{"path":"/backend/erlang/by34qm51/","title":"资源处理器","lang":"zh-CN","frontmatter":{"title":"资源处理器","createTime":"2025/03/28 11:41:32","permalink":"/backend/erlang/by34qm51/"},"headers":[],"readingTime":{"minutes":6.48,"words":1944},"git":{"updatedTime":1743658929000,"contributors":[{"name":"syh","username":"syh","email":"syh@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/060d67e779a1b0aeace68a2a010b367f852e56888393383ea27302df983f6814?d=retro"}]},"filePathRelative":"notes/backend/erlang/rebar3/cowboy/rest/resource_handler.md"}');export{n as comp,i as data};
