import{_ as s,c as a,a as i,o as t}from"./app-C7T5jqfQ.js";const l={};function r(n,e){return t(),a("div",null,e[0]||(e[0]=[i(`<h2 id="启动系统" tabindex="-1"><a class="header-anchor" href="#启动系统"><span>启动系统</span></a></h2><p>使用命令 <code>erl</code> 启动 Erlang 运行时系统：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">%</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> erl</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Erlang/OTP</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 27</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [erts-15.0] </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">64-bit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">smp:8:8</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">ds:8:8:10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">async-threads:1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">jit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Eshell</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> V15.0</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> (press </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Ctrl+G</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> to</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> abort,</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> type</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> help</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">.</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> for</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> help</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">)</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">1&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ERL</code> 可以理解许多命令行参数;看 <a href="https://www.erlang.org/doc/apps/erts/erl_cmd" target="_blank" rel="noopener noreferrer">erl</a> 在 ERTS 应用程序中。本章还介绍了一些参数。</p><p>应用程序可以通过调用以下函数之一来访问命令行参数的值：</p><ul><li><a href="https://www.erlang.org/doc/man/init#get_argument-1" target="_blank" rel="noopener noreferrer"><code>init：get_argument（帮助）</code></a></li><li><a href="https://www.erlang.org/doc/man/init#get_arguments-0" target="_blank" rel="noopener noreferrer"><code>init：get_arguments（）</code></a></li><li><a href="https://www.erlang.org/doc/man/init#get_plain_arguments-0" target="_blank" rel="noopener noreferrer"><code>init：get_plain_arguments（）</code></a></li></ul><h2 id="重新启动和停止系统" tabindex="-1"><a class="header-anchor" href="#重新启动和停止系统"><span>重新启动和停止系统</span></a></h2><p>运行时系统通过调用 <a href="https://www.erlang.org/doc/man/erlang#halt-2" target="_blank" rel="noopener noreferrer"><code>halt/0,1,2</code></a> 的 intent 语句。</p><p>module <a href="https://www.erlang.org/doc/apps/erts/init" target="_blank" rel="noopener noreferrer"><code>init</code></a> 包含用于重启、重启和停止运行时系统的函数：</p><ul><li><a href="https://www.erlang.org/doc/man/init#restart-0" target="_blank" rel="noopener noreferrer"><code>init：restart（）</code></a></li><li><a href="https://www.erlang.org/doc/man/init#reboot-0" target="_blank" rel="noopener noreferrer"><code>init：reboot（） （）</code></a></li><li><a href="https://www.erlang.org/doc/man/init#stop-0" target="_blank" rel="noopener noreferrer"><code>init：stop（）</code></a></li></ul><p>如果 Erlang shell 终止，则运行时系统将终止。</p><h2 id="引导脚本" tabindex="-1"><a class="header-anchor" href="#引导脚本"><span>引导脚本</span></a></h2><p>运行时系统使用<em>引导脚本</em>启动。引导脚本包含有关要加载哪些代码以及要启动哪些进程和应用程序的说明。</p><p>引导脚本文件的扩展名为 <code>.script</code>。运行时系统使用脚本的二进制版本。此<em>二进制引导脚本</em>文件的扩展名为 <code>.boot</code>。</p><p>要使用的引导脚本由命令行标志 <code>-boot</code> 指定。扩展名 <code>.boot</code> 将被省略。例如，使用 boot 脚本 <code>start_all.boot</code> 中：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">%</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> erl</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -boot</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> start_all</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果未指定引导脚本，则默认为 <code>ROOT/bin/start</code>，其中 <code>ROOT</code> 是 Erlang/OTP 的安装目录。请参见<a href="https://www.erlang.org/doc/system/system_principles#default_boot_scripts" target="_blank" rel="noopener noreferrer">默认引导脚本</a>。</p><p>使用命令行标志 <code>-init_debug</code> 时，<code>init</code> 进程将在解释引导脚本时输出调试信息。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">%</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> erl</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -init_debug</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{progress,preloaded}</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{progress,kernel_load_completed}</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{progress,modules_loaded}</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{start,heart}</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{start,logger}</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  .</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  .</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  .copy</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有关引导脚本的语法和内容的详细说明，请参阅 <a href="https://www.erlang.org/doc/man/script" target="_blank" rel="noopener noreferrer"><code>脚本</code></a>。</p><h3 id="默认引导脚本" tabindex="-1"><a class="header-anchor" href="#默认引导脚本"><span>默认引导脚本</span></a></h3><p>Erlang/OTP 附带了这些引导脚本：</p><ul><li><code>start_clean.boot</code> - 加载应用程序 Kernel 和 STDLIB 的代码并启动它们。</li><li><code>start_sasl.boot</code> - 加载并启动应用程序 Kernel、STDLIB 和 SASL 的代码。</li><li><code>no_dot_erlang.boot</code> - 加载应用程序 Kernel 和 STDLIB 的代码并启动它们。跳过加载文件 <code>.erlang</code>。对于无论用户首选项如何，行为相同的脚本和其他工具都很有用。</li></ul><p>使用 <code>start_clean</code> 和 <code>start_sasl</code> 中的哪一个作为默认值由用户在使用 <code>Install</code> 安装 Erlang/OTP 时决定。系统会询问用户：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Do</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> you</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> want</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> to</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> use</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> a</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> minimal</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> system</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> startup</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> instead</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> of</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> the</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> SASL</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> startup?</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果答案是肯定的，则使用 <code>start_clean</code>，否则使用 <code>start_sasl</code>。所选引导脚本将被复制并重命名为 <code>start.boot</code>，然后放入目录 <code>ROOT/bin</code>。</p><h3 id="用户定义的引导脚本" tabindex="-1"><a class="header-anchor" href="#用户定义的引导脚本"><span>用户定义的引导脚本</span></a></h3><p>创建用户定义的引导脚本有时是有用的或必要的。这 尤其在嵌入式模式下运行 Erlang 时是正确的;看 <a href="https://www.erlang.org/doc/system/system_principles#code_loading" target="_blank" rel="noopener noreferrer">代码加载策略</a>。</p><p>虽然可以手动创建引导脚本，但 最好从名为 <code>Name.rel</code> 使用函数 <a href="https://www.erlang.org/doc/man/systools#make_script-2" target="_blank" rel="noopener noreferrer"><code>systools：make_script/1,2</code></a> 的这要求根据 OTP 设计原则将源代码构建为应用程序。</p><p>有关 <code>.rel</code> 文件的更多信息，请参阅 <a href="https://www.erlang.org/doc/system/release_handling" target="_blank" rel="noopener noreferrer">OTP 设计原则</a>和 <a href="https://www.erlang.org/doc/apps/sasl/rel" target="_blank" rel="noopener noreferrer">rel</a> 页面。</p><p>生成二进制引导脚本文件 <code>Name.boot</code> 引导脚本文件 <code>Name.script</code> 中，请使用 <a href="https://www.erlang.org/doc/man/systools#script2boot-1" target="_blank" rel="noopener noreferrer"><code>systools：script2boot（文件）</code></a> 功能。</p><h2 id="代码加载策略" tabindex="-1"><a class="header-anchor" href="#代码加载策略"><span>代码加载策略</span></a></h2><p>运行时系统可以在<em>嵌入式</em>或<em>交互</em>模式下启动。哪一个由命令行标志 <code>-mode</code> 决定：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>% erl -mode embeddedcopy</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>默认模式为 <code>interactive</code>。如果给出了多个 <code>-mode</code> 标志，则将使用第一个标志。</p><p>mode 属性如下：</p><ul><li>在 embedded 模式下，所有代码在系统启动期间根据引导脚本加载。（代码可以在以后通过<strong>显式</strong> 命令 Code Server 加载它。</li><li>在交互模式下，代码在首次需要时动态加载，这意味着当尝试调用未加载的模块中的函数时，代码服务器会搜索代码路径并将模块加载到系统中。</li></ul><p>最初，代码路径由当前工作目录和 <code>ROOT/lib</code> 下的所有目标代码目录组成，其中 <code>ROOT</code> 是 安装目录。目录可以命名为 <code>Name[-Vsn]</code>，其中 <code>-Vsn</code> 后缀是可选的。默认情况下，代码服务器在具有相同 <code>Name</code> 的目录中选择版本号最高的目录。如果 <code>Name[-Vsn]</code> 目录下存在 <code>ebin</code> 目录，则该目录会添加到代码路径中。</p><p>可以使用命令行标志 <code>-pa 目录</code>来扩展代码路径 和 <code>-pz 目录</code>。它们分别将 <code>Directories</code> 添加到代码路径的头部或末尾。例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>% erl -pa /home/arne/mycodecopy</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><a href="https://www.erlang.org/doc/apps/kernel/code" target="_blank" rel="noopener noreferrer"><code>代码</code></a>模块包含许多用于修改和查询搜索路径的函数。</p><h2 id="文件类型" tabindex="-1"><a class="header-anchor" href="#文件类型"><span>文件类型</span></a></h2><p>Erlang/OTP 中定义了以下文件类型：</p><table><thead><tr><th style="text-align:left;"><em>文件类型</em></th><th style="text-align:left;"><em>文件名/扩展名</em></th><th style="text-align:left;"><em>记录在</em></th></tr></thead><tbody><tr><td style="text-align:left;">模块</td><td style="text-align:left;"><code>.erl</code></td><td style="text-align:left;"><a href="https://www.erlang.org/doc/system/modules" target="_blank" rel="noopener noreferrer">Erlang 参考手册</a></td></tr><tr><td style="text-align:left;">包含文件</td><td style="text-align:left;"><code>.hrl</code></td><td style="text-align:left;"><a href="https://www.erlang.org/doc/system/modules" target="_blank" rel="noopener noreferrer">Erlang 参考手册</a></td></tr><tr><td style="text-align:left;">发布资源文件</td><td style="text-align:left;"><code>.rel</code></td><td style="text-align:left;"><a href="https://www.erlang.org/doc/apps/sasl/rel" target="_blank" rel="noopener noreferrer">rel</a> in SASL</td></tr><tr><td style="text-align:left;">应用程序资源文件</td><td style="text-align:left;"><code>.app</code></td><td style="text-align:left;"><a href="https://www.erlang.org/doc/apps/kernel/app" target="_blank" rel="noopener noreferrer">内核中的 app</a></td></tr><tr><td style="text-align:left;">引导脚本</td><td style="text-align:left;"><code>script</code></td><td style="text-align:left;">SASL 中的<a href="https://www.erlang.org/doc/apps/sasl/script" target="_blank" rel="noopener noreferrer">脚本</a></td></tr><tr><td style="text-align:left;">二进制引导脚本</td><td style="text-align:left;"><code>.boot</code></td><td style="text-align:left;">-</td></tr><tr><td style="text-align:left;">配置文件</td><td style="text-align:left;"><code>.config</code></td><td style="text-align:left;"><a href="https://www.erlang.org/doc/apps/kernel/config" target="_blank" rel="noopener noreferrer">内核中的配置</a></td></tr><tr><td style="text-align:left;">应用程序升级文件</td><td style="text-align:left;"><code>.appup</code></td><td style="text-align:left;"><a href="https://www.erlang.org/doc/apps/sasl/appup" target="_blank" rel="noopener noreferrer">SASL 中的 appup</a></td></tr><tr><td style="text-align:left;">发布升级文件</td><td style="text-align:left;"><code>relup</code></td><td style="text-align:left;"><a href="https://www.erlang.org/doc/apps/sasl/relup" target="_blank" rel="noopener noreferrer">SASL 中的 relup</a></td></tr></tbody></table>`,44)]))}const h=s(l,[["render",r]]),o=JSON.parse('{"path":"/backend/erlang/wbdsl5ug/","title":"系统原理","lang":"zh-CN","frontmatter":{"title":"系统原理","createTime":"2025/03/22 15:13:35","permalink":"/backend/erlang/wbdsl5ug/"},"headers":[],"readingTime":{"minutes":4.37,"words":1310},"git":{"updatedTime":1743091220000,"contributors":[{"name":"舒永好","username":"舒永好","email":"shuyonghao@guoshenghuaxing.com","commits":1,"avatar":"https://gravatar.com/avatar/4b1c3f37ea707968be73c631a79de33afd360724ce87bf8f9dcacd67d14df92c?d=retro"}]},"filePathRelative":"notes/backend/erlang/erlang_otp/system_rule/system_rule.md"}');export{h as comp,o as data};
