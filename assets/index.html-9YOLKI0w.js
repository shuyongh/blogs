import{_ as d,c as e,a,o as r}from"./app-C7T5jqfQ.js";const o={};function s(i,t){return r(),e("div",null,t[0]||(t[0]=[a(`<p>REST 在 Cowboy 中作为子协议实现。请求被处理为一个状态机，其中有许多可选回调描述资源并修改机器的行为。</p><p>REST 处理器是处理 HTTP 请求的推荐方式。</p><h2 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h2><p>首先，会调用 <code>init/2</code> 回调。此回调对所有处理器都是通用的。为了使用 REST 处理当前请求，此函数必须返回一个 <code>cowboy_rest</code> 元组。</p><div class="language-erlang line-numbers-mode" data-highlighter="shiki" data-ext="erlang" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">init</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Req</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">, </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">State</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    {</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">cowboy_rest</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Req</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> State</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Cowboy 然后会切换到 REST 协议并开始执行状态机。</p><p>流程图结束时，如果定义了该回调，将调用 <code>terminate/3</code> 回调。</p><h2 id="方法" tabindex="-1"><a class="header-anchor" href="#方法"><span>方法</span></a></h2><p>REST 组件包含处理以下 HTTP 方法的代码：HEAD、GET、POST、PATCH、PUT、DELETE 和 OPTIONS。</p><p>其他方法也可以被接受，但目前没有为它们定义特定的回调。</p><h2 id="回调" tabindex="-1"><a class="header-anchor" href="#回调"><span>回调</span></a></h2><p>所有回调都是可选的。某些回调可能会根据其他已定义回调的返回值而变得必需。下一章中的各种流程图应该有助于您确定需要哪些回调。</p><p>所有回调都接受两个参数，即 Req 对象和 State，并返回一个形式为<code>{Value, Req, State}</code>的三元组。</p><p>几乎所有回调都可以返回<code>{stop, Req, State}</code>以停止请求的执行，或 <code>{{switch_handler, Module}, Req, State}</code> 或 <code>{{switch_handler, Module, Opts}, Req, State}</code> 以切换到不同的处理器类型。例外的是 expires、generate_etag、last_modified 和 variances。</p><p>以下表格总结了各个回调及其默认值。如果未定义回调，则将使用默认值。请参阅流程图以了解每个返回值的结果。</p><p>在以下表格中，“skip”表示如果回调未定义，则直接跳过该回调，进行下一步。“none”表示该回调没有默认值。</p><table><thead><tr><th>回调名称</th><th>默认值</th></tr></thead><tbody><tr><td>allowed_methods</td><td><code>[&lt;&lt;&quot;GET&quot;&gt;&gt;, &lt;&lt;&quot;HEAD&quot;&gt;&gt;, &lt;&lt;&quot;OPTIONS&quot;&gt;&gt;]</code></td></tr><tr><td>allow_missing_post</td><td><code>true</code></td></tr><tr><td>charsets_provided</td><td><code>skip</code></td></tr><tr><td>content_types_accepted</td><td><code>none</code></td></tr><tr><td>content_types_provided</td><td><code>[{{ &lt;&lt;&quot;text&quot;&gt;&gt;, &lt;&lt;&quot;html&quot;&gt;&gt;, &#39;*&#39;}, to_html}]</code></td></tr><tr><td>delete_completed</td><td><code>true</code></td></tr><tr><td>delete_resource</td><td><code>false</code></td></tr><tr><td>expires</td><td><code>undefined</code></td></tr><tr><td>forbidden</td><td><code>false</code></td></tr><tr><td>generate_etag</td><td><code>undefined</code></td></tr><tr><td>is_authorized</td><td><code>true</code></td></tr><tr><td>is_conflict</td><td><code>false</code></td></tr><tr><td>known_methods</td><td><code>[&lt;&lt;&quot;GET&quot;&gt;&gt;, &lt;&lt;&quot;HEAD&quot;&gt;&gt;, &lt;&lt;&quot;POST&quot;&gt;&gt;, &lt;&lt;&quot;PUT&quot;&gt;&gt;, &lt;&lt;&quot;PATCH&quot;&gt;&gt;, &lt;&lt;&quot;DELETE&quot;&gt;&gt;, &lt;&lt;&quot;OPTIONS&quot;&gt;&gt;]</code></td></tr><tr><td>languages_provided</td><td><code>skip</code></td></tr><tr><td>last_modified</td><td><code>undefined</code></td></tr><tr><td>malformed_request</td><td><code>false</code></td></tr><tr><td>moved_permanently</td><td><code>false</code></td></tr><tr><td>moved_temporarily</td><td><code>false</code></td></tr><tr><td>multiple_choices</td><td><code>false</code></td></tr><tr><td>options</td><td><code>ok</code></td></tr><tr><td>previously_existed</td><td><code>false</code></td></tr><tr><td>ranges_provided</td><td>skip</td></tr><tr><td>range_satisfiable</td><td><code>true</code></td></tr><tr><td>rate_limited</td><td><code>false</code></td></tr><tr><td>resource_exists</td><td><code>true</code></td></tr><tr><td>service_available</td><td><code>true</code></td></tr><tr><td>uri_too_long</td><td><code>false</code></td></tr><tr><td>valid_content_headers</td><td><code>true</code></td></tr><tr><td>valid_entity_length</td><td><code>true</code></td></tr><tr><td>variances</td><td><code>[]</code></td></tr></tbody></table><p>你可以看到，Cowboy 尽可能通过使用精心设计的默认值来处理请求，以便继续前进。</p><p>此外，还可以通过 <code>content_types_accepted/2</code>、<code>content_types_provided/2</code> 或 <code>ranges_provided/2</code> 指定任意数量的用户自定义回调。它们可以取任意名称（除了范围回调的 <code>auto</code>），不过建议为每个函数的回调使用单独的前缀。例如，<code>from_html</code> 和 <code>to_html</code> 分别表示在第一种情况下，我们接受以 HTML 格式给出的资源；在第二种情况下，我们发送一个以 HTML 格式的内容。</p><h2 id="元数据" tabindex="-1"><a class="header-anchor" href="#元数据"><span>元数据</span></a></h2><p>Cowboy 将在执行的不同点设置一些信息性的值到 Req 对象中。你可以通过直接匹配 Req 对象来获取这些值。这些值的定义如下表所示：</p><table><thead><tr><th>关键</th><th>详情</th></tr></thead><tbody><tr><td>media_type</td><td>响应实体协商的内容类型</td></tr><tr><td>language</td><td>响应实体协商的语言</td></tr><tr><td>charset</td><td>响应实体协商的字符集</td></tr><tr><td>range</td><td>选择的范围用于响应范围请求</td></tr></tbody></table><p>它们可以用于向使用除 HEAD 或 GET 以外方法的请求发送适当的响应主体。</p><h2 id="响应头" tabindex="-1"><a class="header-anchor" href="#响应头"><span>响应头</span></a></h2><p>Cowboy 会在执行 REST 代码时自动设置响应头。它们列在下面的表格中。</p><table><thead><tr><th>Header 名称</th><th>详情</th></tr></thead><tbody><tr><td>accept-ranges</td><td>资源接受的范围单位</td></tr><tr><td>allow</td><td>资源允许的 HTTP 方法</td></tr><tr><td>content-language</td><td>响应正文使用的语言</td></tr><tr><td>content-range</td><td>响应中找到的内容范围</td></tr><tr><td>content-type</td><td>响应正文的媒体类型和字符集</td></tr><tr><td>etag</td><td>资源的 etag</td></tr><tr><td>expires</td><td>资源的过期日期</td></tr><tr><td>last-modified</td><td>资源的最后修改日期</td></tr><tr><td>location</td><td>请求资源的相对或绝对 URI</td></tr><tr><td>retry-after</td><td>客户端应在访问资源之前等待的时间或延迟</td></tr><tr><td>vary</td><td>可能会影响资源表示的标头列表</td></tr><tr><td>www-authenticate</td><td>访问资源的认证信息</td></tr></tbody></table>`,26)]))}const n=d(o,[["render",s]]),l=JSON.parse('{"path":"/backend/erlang/e70hguvh/","title":"rest处理器","lang":"zh-CN","frontmatter":{"title":"rest处理器","createTime":"2025/03/28 11:36:37","permalink":"/backend/erlang/e70hguvh/"},"headers":[],"readingTime":{"minutes":3.25,"words":975},"git":{"updatedTime":1743658929000,"contributors":[{"name":"syh","username":"syh","email":"syh@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/060d67e779a1b0aeace68a2a010b367f852e56888393383ea27302df983f6814?d=retro"}]},"filePathRelative":"notes/backend/erlang/rebar3/cowboy/rest/rest_handler.md"}');export{n as comp,l as data};
