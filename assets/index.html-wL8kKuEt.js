import{_ as a,c as n,a as s,o as i}from"./app-C7T5jqfQ.js";const r="/blogs/assets/image-20250901110854694-CHV8ljaj.png",l="/blogs/assets/image-20250901111533644-Bm9WX6jX.png",t={};function p(o,e){return i(),n("div",null,e[0]||(e[0]=[s('<div class="hint-container tip"><p class="hint-container-title">提示</p><p><strong>解析表达式语法</strong> （<strong>PEG</strong>）是一种分析性形式语法 ，即它通过一组规则来描述语言中的<a href="https://en.wikipedia.org/wiki/Formal_language" target="_blank" rel="noopener noreferrer">形式语言 </a>，这些规则用于识别语言中的字符串。</p><p>与 CFGs 不同，PEGs 不能产生歧义；一个字符串恰好有一个有效的<a href="https://en.wikipedia.org/wiki/Parse_tree" target="_blank" rel="noopener noreferrer">解析树</a>或没有。</p><p>一个<strong>解析表达式</strong>是一种模式，每个字符串要么<strong>匹配</strong> ，要么<strong>不匹配</strong> 。在匹配的情况下，字符串有一个唯一的<strong>前缀</strong> （这可能是整个字符串，空字符串，或者两者之间的某个部分）被解析表达式<strong>消耗</strong>了；这个前缀就是人们通常认为匹配了表达式的部分。然而，一个字符串是否匹配解析表达式<em>可能</em> （因为前瞻谓词）取决于其消耗部分之后的某些部分。一个<strong>解析表达式语言</strong>是所有匹配某些特定解析表达式的字符串的集合</p></div><h2 id="相关概念" tabindex="-1"><a class="header-anchor" href="#相关概念"><span>相关概念</span></a></h2><h3 id="解析树" tabindex="-1"><a class="header-anchor" href="#解析树"><span>解析树</span></a></h3><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li>一个<strong>解析树</strong>或<strong>分析树</strong>（也称为<strong>推导树</strong>或<strong>具体语法树</strong> ）是一个有序的、有根的树 ，它根据某些<a href="https://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="noopener noreferrer">上下文无关文法</a>表示了一个字符串的<a href="https://en.wikipedia.org/wiki/Syntax" target="_blank" rel="noopener noreferrer">句法</a>结构</li><li>分析树通常基于<strong>短语结构</strong>或<strong>依存结构</strong>来构建。分析树可以为自然语言中的句子生成，也可以在处理计算机语言</li></ul></div><h3 id="短语结构语法" tabindex="-1"><a class="header-anchor" href="#短语结构语法"><span>短语结构语法</span></a></h3><p>:::</p><p>句子的依存结构展示了单词依赖于另外一个单词 (修饰或者是参数)。词与词之间的二元非对称关系称为依存关系，描述为从head (被修饰的主题) 用箭头指向dependent (修饰语)。一般这些依存关系形成树结构，他们通常用语法关系的名称 (主体，介词宾语，同位语等)。</p><p>:::</p><h3 id="依存语法" tabindex="-1"><a class="header-anchor" href="#依存语法"><span>依存语法</span></a></h3><h3 id="基于短语关系的分析树" tabindex="-1"><a class="header-anchor" href="#基于短语关系的分析树"><span>基于短语关系的分析树</span></a></h3><p>基于成分的分析树（<a href="https://en.wikipedia.org/wiki/Phrase_structure_grammar" target="_blank" rel="noopener noreferrer"> 短语结构语法 </a>）<strong>区分终端和非终端节点</strong>。内部节点用语法的 <a href="https://en.wikipedia.org/wiki/Interior_node" target="_blank" rel="noopener noreferrer">非终端 </a>类别标记，而叶节点用 <a href="https://en.wikipedia.org/wiki/Leaf_node" target="_blank" rel="noopener noreferrer">终端 </a>类别标记。下面的图像代表一个基于成分的分析树；它显示了英语句子 <em>John hit the ball</em> 的句法结构：</p><p><img src="'+r+'" alt="image-20250901110854694"></p><p>分析树是整个结构，从 S 开始，到每个叶节点（<em>John</em>、<em>hit</em>、<em>the</em>、<em>ball</em>）结束。在树中使用了以下缩写：</p><ul><li><code>S</code> 代表 <a href="https://en.wikipedia.org/wiki/Sentence_(linguistics)" target="_blank" rel="noopener noreferrer">句子 </a>，本例中的顶层结构。</li><li><code>NP</code> 代表 <a href="https://en.wikipedia.org/wiki/Noun_phrase" target="_blank" rel="noopener noreferrer">名词短语 </a>。第一个（最左侧）NP，一个单独的名词 <em>John</em>，作为句子的 <a href="https://en.wikipedia.org/wiki/Subject_(grammar)" target="_blank" rel="noopener noreferrer">主语 </a>。第二个是句子的 <a href="https://en.wikipedia.org/wiki/Object_(grammar)" target="_blank" rel="noopener noreferrer">宾语 </a>。</li><li><code>VP</code> 代表 <a href="https://en.wikipedia.org/wiki/Verb_phrase" target="_blank" rel="noopener noreferrer">动词短语 </a>，它作为 <a href="https://en.wikipedia.org/wiki/Predicate_(grammar)" target="_blank" rel="noopener noreferrer">谓语 </a>。</li><li><code>V</code> 代表 <a href="https://en.wikipedia.org/wiki/Verb" target="_blank" rel="noopener noreferrer">动词 </a>；在这种情况下，它是 <a href="https://en.wikipedia.org/wiki/Transitive_verb" target="_blank" rel="noopener noreferrer">及物动词 </a><em>hit</em>。</li><li><code>Det</code> 代表<a href="https://en.wikipedia.org/wiki/Determiner_(class)" target="_blank" rel="noopener noreferrer">限定词 </a>；在这种情况下，是<a href="https://en.wikipedia.org/wiki/Article_(grammar)" target="_blank" rel="noopener noreferrer">定冠词 </a><em>the</em>。</li><li><code>N</code> 代表<a href="https://en.wikipedia.org/wiki/Noun" target="_blank" rel="noopener noreferrer">名词 </a>；在这种情况下是<em>球</em> 。</li></ul><p>在一个句子中，只有一个根节点。分支节点是连接到两个或更多子节点的父节点。然而，叶节点是一个终端节点，它不支配树中的其他节点</p><h3 id="基于依存关系的分析树" tabindex="-1"><a class="header-anchor" href="#基于依存关系的分析树"><span>基于依存关系的分析树</span></a></h3><p>基于依存关系的分析树将<a href="https://en.wikipedia.org/wiki/Dependency_grammar" target="_blank" rel="noopener noreferrer">依存语法 </a>[<a href="https://en.wikipedia.org/wiki/Parse_tree#cite_note-6" target="_blank" rel="noopener noreferrer">6]</a> 中的<strong>所有节点视为终结符</strong>，这意味着它们不承认终结符和非终结符类别之间的区别。由于包含的节点较少，它们通常比基于成分的分析树更简单。</p><p><img src="'+l+`" alt="image-20250901111533644"></p><h3 id="如何构建" tabindex="-1"><a class="header-anchor" href="#如何构建"><span>如何构建</span></a></h3><h2 id="快捷键" tabindex="-1"><a class="header-anchor" href="#快捷键"><span>快捷键</span></a></h2><ul><li>重构：提取规则（Ctrl-Alt-M/Cmd-Alt-M）</li><li>重构：引入标记（Ctrl-Alt-C/Cmd-Alt-C）</li><li>编辑：翻转<em>选择</em>分支意图（通过 Alt-Enter）</li><li>编辑：展开/移除表达式（Ctrl-Shift-Del/Cmd-Shift-Del）</li><li>导航：快速语法和 flex 文件结构弹出窗口（Ctrl-F12/Cmd-F12）</li><li>导航：转到相关文件（解析器和 PSI）（Ctrl-Alt-Home/Cmd-Alt-Home）</li><li>导航：导航到匹配的表达式（在属性模式内按 Ctrl-B/Cmd-B）</li><li>高亮：可自定义颜色（通过设置/颜色和字体）</li><li>高亮：固定表达式标记（工具提示显示固定值电荷）</li><li>高亮显示：多个检查项，列表可在设置/检查中查看</li><li>文档：规则文档弹出窗口显示 FIRST/FOLLOWS/PSI 内容（Ctrl-Q/Cmd-J）</li><li>文档：属性文档弹出窗口（按 Ctrl-Q/Cmd-J）</li><li><a href="https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md" target="_blank" rel="noopener noreferrer">实时预览 </a>：打开语言实时预览编辑器（按 Ctrl-Alt-P/Cmd-Alt-P）</li><li><a href="https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md" target="_blank" rel="noopener noreferrer">实时预览 </a>：启动/停止语法评估高亮（在预览编辑器中按 Ctrl-Alt-F7/Cmd-Alt-F7）</li><li>生成器：生成解析器/PSI 代码（按 Ctrl-Shift-G/Cmd-Shift-G）</li><li>生成器：生成自定义 <em>parserUtilClass</em> 类</li><li>生成器：生成*.flex - JFlex 词法定义</li><li>生成器：在*.flex 文件上运行 JFlex 生成器</li><li>图表：PSI 树形图（需要 UML 插件）</li></ul><h2 id="通用使用说明" tabindex="-1"><a class="header-anchor" href="#通用使用说明"><span>通用使用说明</span></a></h2><ol><li>创建语法 *.bnf 文件，请参阅插件代码中的 <a href="https://github.com/JetBrains/Grammar-Kit/blob/master/grammars/Grammar.bnf" target="_blank" rel="noopener noreferrer">Grammar.bnf</a></li><li>使用<em>实时预览</em>加结构视图（Ctrl-Alt-P / Cmd-Alt-P）调整语法</li><li>生成解析器/ElementTypes/PSI 类（Ctrl-Shift-G / Cmd-Shift-G）</li><li>生成 lexer *.flex 文件，然后运行 JFlex 生成器（两者均通过右键菜单操作）</li><li>实现 ParserDefinition 并添加相应的注册到 plugin.xml 文件</li><li>混入解析和其他非平凡功能到 PSI</li></ol><h2 id="语法" tabindex="-1"><a class="header-anchor" href="#语法"><span>语法</span></a></h2><h3 id="属性" tabindex="-1"><a class="header-anchor" href="#属性"><span>属性</span></a></h3><p>基本语法通过<strong>全局属性</strong>和<strong>规则属性</strong>进行扩展。属性通过花括号内的一组 <em>name=value</em> 对来指定。</p><ul><li>规则属性放置在规则定义之后。</li><li>全局属性放置在顶部或用分号与规则定义分开。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>// Basic PEG BNF syntax</span></span>
<span class="line"><span></span></span>
<span class="line"><span>root_rule ::= rule_A rule_B rule_C rule_D                // sequence expression</span></span>
<span class="line"><span>rule_A ::= token | &#39;or_text&#39; | &quot;another_one&quot;             // choice expression</span></span>
<span class="line"><span>rule_B ::= [ optional_token ] and_another_one?           // optional expression</span></span>
<span class="line"><span>rule_C ::= &amp;required !forbidden                          // predicate expression</span></span>
<span class="line"><span>rule_D ::= { can_use_braces + (and_parens) * }           // grouping and repetition</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Grammar-Kit BNF syntax</span></span>
<span class="line"><span></span></span>
<span class="line"><span>{ generate=[psi=&quot;no&quot;] }                                  // top-level global attributes</span></span>
<span class="line"><span>private left rule_with_modifier ::= &#39;+&#39;                  // rule modifiers</span></span>
<span class="line"><span>left rule_with_attributes ::= &#39;?&#39; {elementType=rule_D}   // rule attributes</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private meta list ::= &lt;&lt;p&gt;&gt; (&#39;,&#39; &lt;&lt;p&gt;&gt;) *                // meta rule with parameters</span></span>
<span class="line"><span>private list_usage ::= &lt;&lt;list rule_D&gt;&gt;                   // meta rule application</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="规则修饰符" tabindex="-1"><a class="header-anchor" href="#规则修饰符"><span>规则修饰符</span></a></h3><ul><li><p><code>private</code>（PSI 树）：跳过节点创建，并让其子节点包含在其父节点中。</p></li><li><p><code>left</code> （PSI 树）：取左侧的 AST 节点（前一个兄弟节点）并成为其父节点。</p></li><li><p><code>inner</code> （PSI 树）：取左侧的 AST 节点（前一个兄弟节点）并注入自身成为其子节点。</p></li><li><p><code>upper</code>（PSI 树）：取父节点并用其所有子节点替换它。</p></li><li><p><code>meta</code> （解析器）：一个参数化规则；其解析函数可以接受其他解析函数作为参数。</p></li><li><p><code>external</code> （解析器）：具有手写解析函数的规则；不生成解析代码。</p></li><li><p><code>fake</code>（PSI 类）：用于塑造生成的 PSI 类的规则；仅生成 PSI 类。</p></li></ul><p>修饰符可以组合， <em>内部</em>应仅与<em>左</em>一起使用， <em>私有左</em>等价于<em>私有左内部</em> ， <em>fake</em> 不应与 <em>private</em> 结合使用。</p><p>默认情况下，规则是 <em>public</em>，即 <em>非 private</em>， <em>非 fake</em> 等。</p><h3 id="附加规则" tabindex="-1"><a class="header-anchor" href="#附加规则"><span>附加规则</span></a></h3><p>使用{},如</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>// 记录系统 花括号 { ... } 中的内容是为这个语法规则附加的元数据和行为</span></span>
<span class="line"><span>record_definition ::= &#39;-&#39; &#39;record&#39; &#39;(&#39; q_atom &#39;,&#39; typed_record_fields &#39;)&#39; {</span></span>
<span class="line"><span>  pin=2</span></span>
<span class="line"><span>  methods = [getName setName getNameIdentifier getTextOffset]</span></span>
<span class="line"><span>  stubClass=&quot;org.intellij.erlang.stubs.ErlangRecordDefinitionStub&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="外部表达式" tabindex="-1"><a class="header-anchor" href="#外部表达式"><span>外部表达式</span></a></h3><p>外部表达式 <em>&lt;&lt; ... &gt;&gt;</em> 是外部规则的内联变体。它也可以用来指定带有参数的元规则。</p><p>例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>meta comma_separated_list ::= &lt;&lt;param&gt;&gt; ( &#39;,&#39; &lt;&lt;param&gt;&gt; ) *</span></span>
<span class="line"><span>option_list ::= &lt;&lt;comma_separated_list (OPTION1 | OPTION2 | OPTION3)&gt;&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>外部规则表达式语法与外部表达式体相同：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span> external manually_parsed_rule ::= methodName param1 param2 ...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>外部表达式和外部规则对双引号和单引号字符串的处理方式不同。通常，在规则或方法名称之后出现在外部表达式中的任何内容都被视为参数，并以“原样”传递，除非是单引号字符串，这些字符串在传递之前会被去除引号。这有助于传递有资格的枚举常量、Java 表达式等。</p><h3 id="标记" tabindex="-1"><a class="header-anchor" href="#标记"><span>标记：</span></a></h3><p>显式标记通过 <em>tokens</em> 全局属性声明，例如在 <em>token_name=token_value</em> 形式中。标记名称用于 IElementType 标记常量，标记值通常是它的单引号或双引号中的字符串表示。</p><p>语法中的标记可以通过名称或值（单引号或双引号）引用。建议尽可能使用值以提高可读性。当存在一个未引用的标记值也匹配某些规则时，可以使用名称来解决冲突。</p><p>隐式标记是没有通过 <em>tokens</em> 属性指定的标记。未引用的隐式标记（也称为关键字标记）的名称等于它们的值。引用的隐式标记（也称为文本匹配标记）较慢，因为它们是通过文本而不是通过词法分析器返回的 IElementType 常量来匹配的。文本匹配标记可以跨越词法分析器返回的多个实际标记。</p><p>规则、标记和文本匹配标记有不同的颜色。</p><h3 id="错误恢复和报告的属性" tabindex="-1"><a class="header-anchor" href="#错误恢复和报告的属性"><span>错误恢复和报告的属性：</span></a></h3><ul><li><em>pin</em>（值：一个数字或模式）调整解析器以处理不完整匹配。如果一个序列的前缀（直到一个固定的项目）匹配，则该序列匹配。在成功到达固定的项目后，解析器尝试匹配其余的项目，无论它们是否匹配。固定值通过数字 <em>{pin=2}</em> 或模式 <em>{pin=&quot;rule_B&quot;}</em> 来指示所需的项目。 默认情况下，固定值应用于顶层序列表达式。可以使用目标模式包含子表达式： <em>{pin(&quot;.*&quot;)=1}</em> 适用于所有子序列。</li><li><em>recoverWhile</em>（值：谓词规则）匹配规则匹配完成后出现的任意数量的标记。此属性有助于解析器在遇到未匹配的标记序列时恢复。有关更多信息，请参阅<a href="https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#22-using-recoverwhile-attribute" target="_blank" rel="noopener noreferrer">如何操作部分 </a>。</li><li><em>name</em>（值：字符串）指定用于错误报告的规则名称。例如，*name(&quot;_.<em>expr&quot;)=expression</em> 将表达式错误消息更改为 &quot;必需&quot; 而不是长列表的标记。</li></ul><h3 id="生成的解析器结构" tabindex="-1"><a class="header-anchor" href="#生成的解析器结构"><span>生成的解析器结构：</span></a></h3><p>生成器可以将解析器代码拆分为几个类，以更好地支持大型语法。</p><p>在简单情况下，解析器将仅由几个生成的类组成。</p><p>实际的错误恢复和报告代码，以及基于解析器的完成提供程序支持代码和基本令牌匹配代码都位于一个名为 <em>parserUtilClass</em> 的类中。可以通过指定一个扩展或模仿原始的 <a href="https://github.com/JetBrains/Grammar-Kit/blob/master/src/org/intellij/grammar/parser/GeneratedParserUtilBase.java" target="_blank" rel="noopener noreferrer">GeneratedParserUtilBase</a> 的其他类来修改它。无需在项目中保留 GeneratedParserUtilBase 的副本，它自 12.1 版本以来已包含在 <em>IntelliJ 平台</em> 中。</p><p>手动解析代码，即 <em>外部</em> 规则必须以与生成相同的方式实现，通过 <em>parserUtilClass</em> 类中的静态方法或任何其他将通过 <em>parserImports</em> 属性导入的类，如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  parserImports=[&quot;static org.sample.ManualParsing.*&quot;]</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="词法分析和-psi" tabindex="-1"><a class="header-anchor" href="#词法分析和-psi"><span>词法分析和 PSI</span></a></h3><p>由解析器生成器生成的 IElementType 常量必须被词法分析器识别并返回。基于 JFlex 的词法分析器可以从定义所有所需标记的语法中生成（ <em>生成 JFlex 词法分析器</em>菜单）。</p><p>在*.flex 文件中， <em>运行 JFlex 生成器</em>菜单会调用 JFlex 生成词法分析器 Java 代码。关键字可以直接从用法中选取，而像<em>字符串</em> 、 <em>标识符</em>和<em>注释</em>这样的标记可以像这样定义（来自<a href="https://github.com/JetBrains/Grammar-Kit/blob/master/TUTORIAL.md" target="_blank" rel="noopener noreferrer">教程 </a>）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>  tokens=[</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    comment=&#39;regexp://.*&#39;</span></span>
<span class="line"><span>    number=&#39;regexp:\\d+(\\.\\d*)?&#39;</span></span>
<span class="line"><span>    id=&#39;regexp:\\p{Alpha}\\w*&#39;</span></span>
<span class="line"><span>    string=&quot;regexp:(&#39;([^&#39;\\\\]|\\\\.)*&#39;|\\&quot;([^\\&quot;\\\\]|\\\\.)*\\&quot;)&quot;</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>  ]</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>词法分析器可以单独提供，或者可以使用生成的 *.flex 文件作为基础。</p><p>解析器生成器默认生成标记类型常量和 PSI。这可以通过 <em>generateTokens</em> 和 <em>generatePSI</em> 全局布尔属性分别关闭。</p><p><em>elementType</em> 规则属性允许混合生成的代码和一些现有的手动 PSI。</p><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>private form ::=</span></span>
<span class="line"><span>    is_config config_expression</span></span>
<span class="line"><span>  | function</span></span>
<span class="line"><span>  | record_definition</span></span>
<span class="line"><span>  | include_lib</span></span>
<span class="line"><span>  | include</span></span>
<span class="line"><span>  | macros_definition</span></span>
<span class="line"><span>  | type_definition</span></span>
<span class="line"><span>  | attribute</span></span>
<span class="line"><span>  | macros_call // macros support</span></span>
<span class="line"><span>  | rule</span></span>
<span class="line"><span>  | !&lt;&lt;eofOrSpace&gt;&gt; /*&amp;(!&#39;.&#39;)*/</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>record_definition ::= &#39;-&#39; &#39;record&#39; &#39;(&#39; q_atom &#39;,&#39; typed_record_fields &#39;)&#39; {</span></span>
<span class="line"><span>  pin=2</span></span>
<span class="line"><span>  methods = [getName setName getNameIdentifier getTextOffset]</span></span>
<span class="line"><span>  stubClass=&quot;org.intellij.erlang.stubs.ErlangRecordDefinitionStub&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>花括号 <code>{ ... }</code> 中的内容是为这个语法规则附加的元数据和行为</p><p><strong><code>pin = 2</code></strong></p><ul><li><strong>作用</strong>：<strong>“固定”</strong> 关键字。这是一个非常重要的恢复性解析（Resilient Parsing）提示。</li><li><strong>解释</strong>：它告诉语法分析器（Parser），在解析过程中如果发生错误，它应该在第 <strong>2</strong> 个元素（即 <code>&#39;record&#39;</code> 关键字）处尝试重新同步和恢复解析。</li><li><strong>举例</strong>：如果用户在代码中输入了不完整的记录 <code>-record(</code> 然后就去干别的了，解析器会因为缺少元素而报错。但由于 <code>pin=2</code> 的存在，IntelliJ IDEA 仍然能够识别出这是一个记录定义的开始，并在此基础上提供代码补全、语法高亮等功能，而不是将后续所有代码都视为错误。</li></ul><p><strong><code>methods = [ ... ]</code></strong></p><ul><li><strong>作用</strong>：为由此规则生成的 <strong>PSI（Program Structure Interface）元素</strong> 显式声明或生成特定的方法。</li><li><strong>解释</strong>：PSI 是 IDE 对源代码的结构化抽象表示。这里指定了该 PSI 元素需要拥有哪些方法： <ul><li><code>getName()</code>: 返回记录的名称（如 <code>&quot;person&quot;</code>）。用于在 IDE 功能中按名称引用记录。</li><li><code>setName(String name)</code>: 允许通过重构操作（如重命名）来设置记录的新名称。</li><li><code>getNameIdentifier()</code>: 返回代表记录名称的 <strong>PSI 元素本身</strong>（而不仅仅是字符串）。这对于精确找到名称在文件中的位置至关重要，例如用于重命名重构或查找用法。</li><li><code>getTextOffset()</code>: 返回该元素在文件中的文本偏移量（起始位置）。用于导航和定位。</li></ul></li></ul><p><strong><code>stubClass=&quot;org.intellij.erlang.stubs.ErlangRecordDefinitionStub&quot;</code></strong></p><ul><li><strong>作用</strong>：将此 PSI 元素与一个 <strong>Stub</strong> 类关联起来。这是实现<strong>索引（Indexing）</strong> 和<strong>跨文件解析</strong>的关键，能极大提升 IDE 性能。</li><li><strong>解释</strong>： <ul><li><strong>Stub</strong> 是 PSI 元素的一种轻量级、序列化的表示形式，只包含最基本的信息（如名称、导出状态等），而不包含完整的语法树信息。</li><li>当项目首次打开或文件改变时，IDE 会解析文件并将其关键元素的 Stub 序列化后存入磁盘索引。</li><li>当需要<strong>跨文件</strong>查找信息时（例如，在另一个文件中输入 <code>#person{}</code>），IDE 无需完全解析所有文件，只需从磁盘快速加载轻量的 Stub 索引，就能知道 <code>person</code> 记录是否存在、它的字段是什么。</li><li>这行代码指定了用于存储 <code>record_definition</code> 信息的 Stub 类的具体实现。</li></ul></li></ul><hr>`,73)]))}const c=a(t,[["render",p]]),m=JSON.parse('{"path":"/article/4wvuba1o/","title":"解析表达式语法","lang":"zh-CN","frontmatter":{"title":"解析表达式语法","createTime":"2025/09/01 10:29:20","permalink":"/article/4wvuba1o/","tags":["逻辑语法"]},"headers":[],"readingTime":{"minutes":12.09,"words":3628},"git":{"updatedTime":1758260391000,"contributors":[{"name":"syh","username":"syh","email":"syh@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/060d67e779a1b0aeace68a2a010b367f852e56888393383ea27302df983f6814?d=retro"}]},"filePathRelative":"blog/后端/peg.md","categoryList":[{"id":"126ac9","sort":10004,"name":"blog"},{"id":"4ad65e","sort":10005,"name":"后端"}]}');export{c as comp,m as data};
