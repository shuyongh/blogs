import{_ as i,c as s,a,o as t}from"./app-C7T5jqfQ.js";const l={};function d(n,e){return t(),s("div",null,e[0]||(e[0]=[a(`<h2 id="emake文件" tabindex="-1"><a class="header-anchor" href="#emake文件"><span>Emake文件</span></a></h2><blockquote><p>Emake用于将一堆erlang文件进行组合编译，运行</p><p>模块<code> make</code> 提供了一组类似于 UNIX 类型 <code>Make</code> 的函数 功能。</p></blockquote><h3 id="文件语法" tabindex="-1"><a class="header-anchor" href="#文件语法"><span>文件语法</span></a></h3><p><a href="https://www.erlang.org/doc/apps/tools/make#all/1" target="_blank" rel="noopener noreferrer"><code>make：all/0,1</code></a> 和 <a href="https://www.erlang.org/doc/apps/tools/make#files/2" target="_blank" rel="noopener noreferrer"><code>make：files/1,2</code></a> 首先查找 <code>{emake， Emake}</code> ，然后在当前工作目录中查找名为 <code>Emakefile</code> 的文件。如果存在，<code>Emake</code> 应包含如下元素：</p><div class="language-erlang line-numbers-mode" data-highlighter="shiki" data-ext="erlang" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Modules</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Options</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p><code>Modules</code> 是一个原子或原子列表。可以是</p><ul><li><p>模块名称，对于 <code>exmaple，file1</code></p></li><li><p>另一个目录中的模块名称，例如 <code>&#39;../foo/file3&#39;</code></p></li><li><p>用通配符指定的一组模块，例如，<code>&#39;file*&#39;</code></p></li><li><p>表示当前目录中所有模块的通配符，即：<code>&#39;*&#39;</code></p></li><li><p>以上任何一项的列表，例如， <code>[&#39;file*&#39;,&#39;../foo/file3&#39;,&#39;File4&#39;]</code></p></li></ul></li><li><p><code>Options</code> 是编译器选项的列表。</p></li></ul><p><code>Emakefile</code> 是从上到下读取的。如果模块与多个条目匹配，则使用第一个匹配项。例如，以下 <code>Emakefile</code> 表示 <code>file1</code> 应该使用选项 <code>[debug_info，{i，“../foo“}]</code>，而 当前目录中的所有其他文件都应该只使用 <code>debug_info</code> 标志。</p><div class="language-erlang line-numbers-mode" data-highlighter="shiki" data-ext="erlang" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{&#39;</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">file1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&#39;,[</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">debug_info</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,{</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">../foo</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}]}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{&#39;</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&#39;,[</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">debug_info</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><ul><li>命令行使用</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>%% 1,编译i选择指定目录下的文件</span></span>
<span class="line"><span>erl -make</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%%  2,启动erlang shell , -pa &lt;directory&gt; 选项告诉 Erlang VM 将该路径添加到它可以在其中查找模块的位置</span></span>
<span class="line"><span>erl -pa ebin/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>模块中使用</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>%% 在当前目录中查找名为“Emakefile”的文件，重新编译它（如果它已更改），并加载新文件。</span></span>
<span class="line"><span>make:all([load])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="make模块" tabindex="-1"><a class="header-anchor" href="#make模块"><span>make模块</span></a></h3><table><thead><tr><th>函数</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>all()</code></td><td>等效于 <code>all（[]）</code></td><td></td></tr><tr><td><code>all(Options)</code></td><td>此函数确定要编译的模块集和要使用的编译选项，首先查找 <code>emake</code> 选项，如果不存在，则从名为 <code>Emakefile</code> 的文件中读取配置（见下文）。如果未找到此类文件，则要编译的模块集默认为当前工作目录中的所有模块。</td><td></td></tr><tr><td><code>files(ModFiles)</code></td><td>等价于 <code>files（ModFiles， []）</code>。</td><td></td></tr><tr><td><code>files(ModFiles,Options)</code></td><td>此函数与 <code>all/0,1</code>执行完全相同的作，但对于指定的 <code>ModFiles</code>，即模块或文件名的列表。</td><td></td></tr></tbody></table><h3 id="all-1" tabindex="-1"><a class="header-anchor" href="#all-1"><span>all/1</span></a></h3><blockquote><p>此函数确定要编译的模块集和要使用的编译选项，首先查找 <code>emake</code> 选项，如果不存在，则从名为 <code>Emakefile</code> 的文件中读取配置（见下文）。如果未找到此类文件，则要编译的模块集默认为当前工作目录中的所有模块。</p></blockquote><div class="language-erlang line-numbers-mode" data-highlighter="shiki" data-ext="erlang" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">-</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">spec</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> all</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Options</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -&gt;</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> up_to_date</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">error</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">             when</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                 Options</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ::</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Option</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                 Option</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ::</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> noexec</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">load</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">netload</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">emake</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Emake</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">compile</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">option</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                 Emake</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ::</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">EmakeElement</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                 EmakeElement</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ::</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Modules</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Modules</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">compile</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">option</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()]}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">                 Modules</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ::</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> atom</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">atom</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()].</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遍历模块集，然后重新编译至少满足以下条件之一的每个模块：</p><ul><li>没有对象文件，或者</li><li>源文件自上次编译后已被修改，或者</li><li>自上次编译源文件以来，已修改包含文件。</li></ul><p>作为副作用，该函数会打印它尝试编译的每个模块的名称。如果模块编译失败，则 make 过程将停止并显示<code>错误</code> 返回。</p><p><code>Options</code> 是 <code>make</code> 和 Erlang 编译器的选项列表。以下 <code>make</code> 选项存在：</p><ul><li><code>noexec</code> 无执行模式。只打印每个需要 编译。</li><li><code>load</code> 加载模式。加载所有重新编译的模块。</li><li><code>netload</code> Net load 模式。在所有已知节点上加载所有重新编译的模块。</li><li><code>{emake， emake}</code> 显式指定配置，而不是读取 <code>Emakefile</code>。</li></ul><p><code>Options</code> 中所有不是 make 选项的项目都被假定为编译器选项，并按原样传递给 <a href="https://www.erlang.org/doc/apps/compiler/compile#file/2" target="_blank" rel="noopener noreferrer"><code>compile：file/2</code></a>。</p><h3 id="files-2" tabindex="-1"><a class="header-anchor" href="#files-2"><span>files/2</span></a></h3><blockquote><p>用于编译 Erlang 源文件的核心函数，它提供了比 <code>make:all/0</code> 更细粒度的编译控制能力。</p></blockquote><div class="language-erlang line-numbers-mode" data-highlighter="shiki" data-ext="erlang" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">make</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">files</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Files</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Options</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -&gt;</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> up_to_date</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">error</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> | </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">error</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Reason</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>参数</strong></p><ul><li><code>Files</code> <code>[string() | atom()]</code> 说明：要编译的文件列表，可以是： <ul><li>带 <code>.erl</code> 扩展名的文件名（字符串）</li><li>不带扩展名的模块名（原子）</li></ul></li><li><code>Options </code> 类型：<code>[option()]</code> 说明：编译选项列表，支持所有 <code>compile:file/2</code> 选项，还包括：</li></ul><table><thead><tr><th style="text-align:left;">选项</th><th style="text-align:left;">类型</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>noexec</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">只检查不实际编译</td></tr><tr><td style="text-align:left;"><code>load</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">编译后自动加载</td></tr><tr><td style="text-align:left;"><code>netload</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">网络加载</td></tr><tr><td style="text-align:left;"><code>depend</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">生成依赖关系</td></tr><tr><td style="text-align:left;"><code>verbose</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">显示详细输出</td></tr><tr><td style="text-align:left;"><code>dry_run</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">模拟运行不实际修改文件</td></tr><tr><td style="text-align:left;"><code>continue</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">遇到错误继续处理其他文件</td></tr><tr><td style="text-align:left;"><code>parallel</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">并行编译</td></tr><tr><td style="text-align:left;"><code>{i, Dir}</code></td><td style="text-align:left;">string</td><td style="text-align:left;">添加包含目录</td></tr><tr><td style="text-align:left;"><code>{d, Macro}</code></td><td style="text-align:left;">atom</td><td style="text-align:left;">定义宏</td></tr><tr><td style="text-align:left;"><code>{d, Macro, Value}</code></td><td style="text-align:left;">tuple</td><td style="text-align:left;">定义带值的宏</td></tr><tr><td style="text-align:left;"><code>{outdir, Dir}</code></td><td style="text-align:left;">string</td><td style="text-align:left;">指定输出目录</td></tr><tr><td style="text-align:left;"><code>{crossref, bool}</code></td><td style="text-align:left;">boolean</td><td style="text-align:left;">生成交叉引用</td></tr></tbody></table><p><strong>返回值</strong></p><ul><li><code>up_to_date</code>：所有文件都是最新的</li><li><code>error</code>：编译出错</li><li><code>{error, Reason}</code>：带详细错误信息的失败</li></ul><h2 id="reltool" tabindex="-1"><a class="header-anchor" href="#reltool"><span>reltool</span></a></h2><blockquote><p><em>Reltool</em> 是一个版本管理工具。它分析给定的 Erlang/OTP 安装并确定各种应用程序之间的依赖关系。前端图形界面展示了这些依赖关系，并允许用户交互式地自定义目标系统。后端提供了批量接口，用于生成自定义的目标系统。</p></blockquote><p>该工具使用已安装的 Erlang/OTP 系统作为输入。</p><ul><li><code>root_dir</code> 是被分析系统的根目录，它默认为执行 Reltool 的系统。应用程序也可能位于 <code>root_dir</code> 之外。</li><li><code>lib_dirs</code> 定义了额外应用程序可能存在的库目录，它默认为由操作系统环境变量 <code>ERL_LIBS</code> 列出的目录。 <ul><li>在库目录下的一个应用程序目录 <code>AppDir</code> 将通过存在 <code>AppDir/ebin</code> 目录来被识别。如果不存在此目录，Reltool 在查找应用程序时将完全忽略 <code>AppDir</code>。</li></ul></li></ul><h3 id="界面" tabindex="-1"><a class="header-anchor" href="#界面"><span>界面</span></a></h3><h4 id="系统窗口" tabindex="-1"><a class="header-anchor" href="#系统窗口"><span>系统窗口</span></a></h4><blockquote><p>系统窗口通过函数 <a href="https://www.erlang.org/doc/apps/reltool/reltool#start/1" target="_blank" rel="noopener noreferrer"><code>reltool:start/1</code></a> 启动。启动时，工具将处理所有 <code>beam</code> 文件和 <code>app</code> 文件，以确定应用程序及其模块之间的依赖关系</p></blockquote><p>系统窗口由四个主要页面（标签页）组成：</p><ul><li>库</li><li>系统设置 <ul><li>可以控制一些全局设置 用作所有应用程序的默认值。设置 <code>Application inclusion policy</code>以 <code>include </code>来包含所有未明确排除的应用。</li></ul></li><li>应用程序</li><li>发行版</li></ul><p>点击名称标签以显示其页面。</p><h4 id="应用程序窗口" tabindex="-1"><a class="header-anchor" href="#应用程序窗口"><span>应用程序窗口</span></a></h4><p>应用程序窗口通过双击应用程序名称来启动。应用程序窗口由四个页面（标签页）组成：</p><ul><li>应用设置</li><li>模块</li><li>应用依赖项</li><li>模块依赖项</li></ul><p>点击名称标签以显示其页面。</p><h4 id="模块窗口" tabindex="-1"><a class="header-anchor" href="#模块窗口"><span>模块窗口</span></a></h4><p>通过双击模块名称来启动模块窗口。模块窗口最初由两个页面（标签页）组成：</p><ul><li>依赖项</li><li>代码</li></ul><p>点击名称标签以显示其页面。</p><h3 id="快速开始" tabindex="-1"><a class="header-anchor" href="#快速开始"><span>快速开始</span></a></h3><h2 id="eunit" tabindex="-1"><a class="header-anchor" href="#eunit"><span>EUnit</span></a></h2><blockquote><p><code>EUnit</code> 是 Erlang 的单元测试框架</p></blockquote><h3 id="快速开始-1" tabindex="-1"><a class="header-anchor" href="#快速开始-1"><span>快速开始</span></a></h3><h4 id="引入库" tabindex="-1"><a class="header-anchor" href="#引入库"><span>引入库</span></a></h4><p>在<code>erlang</code>模块中引入库</p><div class="language-erlang line-numbers-mode" data-highlighter="shiki" data-ext="erlang" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">-</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">include_lib</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">eunit/include/eunit.hrl</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">).</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这将产生以下效果：</p><ul><li>创建一个导出函数 test()（除非关闭测试，并且模块中不包含 test()函数），该函数可以用于运行模块中定义的所有单元测试</li><li>使所有名称匹配..._test()或...<em>test</em>()的所有函数 除非关闭测试功能或定义了 <code>EUNIT_NOAUTO</code> 宏，否则会自动从模块中导出 除非关闭测试功能或定义了 <code>EUNIT_NOAUTO</code> 宏，否则会自动从模块中导出</li><li>让<code>EUnit</code>的所有预处理器宏都可用，以帮助编写测试代码</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>对于 <code>-include_lib(...)</code> 要生效，Erlang 模块搜索路径<em>必须</em> 包含一个名称以 <code>eunit/ebin</code> 结尾的目录（指向 <code>ebin</code>） (EUnit 安装目录下的子目录)。如果 EUnit 是安装的， 在 Erlang/OTP 系统目录下的 <code>lib/eunit</code>，其 <code>ebin</code> 子目录将在 Erlang 启动时自动添加到搜索路径中。否则，您需要显式地添加该目录，通过向 <code>erl</code> 或 <code>erlc</code> 命令。例如，一个 Makefile 可以包含编译 <code>.erl</code> 文件的如下操作：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>  erlc -pa &quot;path/to/eunit/ebin&quot; $(ERL_COMPILE_FLAGS) -o$(EBIN) $&lt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>或者如果你想在运行 Erlang 交互模式时始终可用 Eunit，可以在你的 <code>$HOME/.erlang</code> 文件中添加如下一行：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>   code:add_path(&quot;/path/to/eunit/ebin&quot;).</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></div><h4 id="编写示例" tabindex="-1"><a class="header-anchor" href="#编写示例"><span>编写示例</span></a></h4><p>一个名为..._test() 的函数会被 EUnit 识别为一个简单的测试函数</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>   reverse_nil_test() -&gt; [] = lists:reverse([]).</span></span>
<span class="line"><span>   reverse_one_test() -&gt; [1] = lists:reverse([1]).</span></span>
<span class="line"><span>   reverse_two_test() -&gt; [2,1] = lists:reverse([1,2]).</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="运行eunit" tabindex="-1"><a class="header-anchor" href="#运行eunit"><span>运行EUnit</span></a></h4><blockquote><p>如果您已经在模块中添加了声明 <code>-include_lib(&quot;eunit/include/eunit.hrl&quot;)</code> ，如上所述，您只需编译模块并运行自动导出的函数 <code>test()</code>。例如，如果您的模块名为 <code>m</code>，那么调用 <code>m:test()</code> 将在模块中定义的所有测试上运行 EUnit。您不需要为测试函数编写 <code>-export</code> 声明</p><p>也可以使用函数 <a href="https://www.erlang.org/doc/apps/eunit/eunit#test/1" target="_blank" rel="noopener noreferrer"><code>eunit:test/1</code></a> 来运行任意测试</p></blockquote><p><code>eunit:test(aaa)</code>会运行<code>aaa</code>模块中的所有测试和<code>aaa_tests</code>模块中的所有测试</p><h3 id="eunit宏" tabindex="-1"><a class="header-anchor" href="#eunit宏"><span>Eunit宏</span></a></h3><h4 id="基本宏" tabindex="-1"><a class="header-anchor" href="#基本宏"><span>基本宏</span></a></h4><ul><li><strong><code>_test(Expr)</code></strong> - 将 <code>Expr</code> 转换为一个“测试对象”，通过将其包装在一个 fun-expression 和一行源代码编号。等同于 <code>{?LINE, fun () -&gt; (Expr) end}</code>.</li></ul><h4 id="编译控制宏" tabindex="-1"><a class="header-anchor" href="#编译控制宏"><span>编译控制宏</span></a></h4><ul><li><p><strong><code>EUNIT</code></strong> - 这个宏在编译时启用 EUnit 时总是定义为 <code>true</code>。这通常用于在条件编译中放置测试代码，例如：</p><div class="language-eralng line-numbers-mode" data-highlighter="shiki" data-ext="eralng" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>   -ifdef(EUNIT).</span></span>
<span class="line"><span>       % test code here</span></span>
<span class="line"><span>       ...</span></span>
<span class="line"><span>   -endif.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如，当测试被禁用时，为了确保代码可以在不包含 EUnit 头文件的情况下编译，</p></li><li><p><strong><code>EUNIT_NOAUTO</code></strong> - 如果定义了此宏，将禁用测试函数的自动导出或剥离。</p></li><li><p><strong><code>TEST</code></strong> - 无论何时在编译时启用 EUnit，此宏总是定义为 <code>true</code>，除非用户之前将其定义为其他值。此宏可用于条件编译；</p><p>对于严格依赖于 EUnit 的测试代码，使用 <code>EUNIT</code> 宏可能更为合适，而对于使用更通用测试惯例的代码，使用 <code>TEST</code> 宏可能更为合适。</p><p>也可以使用 <code>TEST</code> 宏来覆盖 <code>NOTEST</code> 宏。如果 <code>TEST</code> 在 EUnit 头文件被包含之前被定义（即使 <code>NOTEST</code> 也被定义），则代码将编译为启用 EUnit。</p></li><li><p><strong><code>NOTEST</code></strong> - 这个宏在任何时候都会被定义（除非用户在编译时将其定义为其他值，否则定义为 <code>true</code>），当 EUnit 在编译时被禁用时。请将 <code>TEST</code> 宏进行对比。</p><p>这个宏也可以用于条件编译，但通常用于禁用测试：如果在包含 EUnit 头文件之前定义了 <code>NOTEST</code>，并且没有定义 <code>TEST</code>，那么代码将被编译为禁用 EUnit。</p></li><li><p><strong><code>NOASSERT</code></strong> - 如果此宏被定义，断言宏将不起作用 当测试也被禁用时，效果也会消失。见 <a href="https://www.erlang.org/doc/apps/eunit/chapter#Assert_macros" target="_blank" rel="noopener noreferrer">断言宏 </a>。当启用测试时，断言宏会自动启用并且无法禁用。</p></li><li><p><strong><code>ASSERT</code></strong> - 如果定义了此宏，则会覆盖 NOASSERT 宏，强制使断言宏始终启用，而不受其他设置的影响。</p></li><li><p><strong><code>NODEBUG</code></strong> - 如果定义了此宏，调试宏将不起作用。详见 <a href="https://www.erlang.org/doc/apps/eunit/chapter#Debugging_macros" target="_blank" rel="noopener noreferrer">调试宏 </a>。<code>NODEBUG</code> 还隐含 <code>NOASSERT</code>，除非启用了测试。</p></li><li><p><strong><code>DEBUG</code></strong> - 如果定义了此宏，它将覆盖 NODEBUG 宏，强制启用调试宏。</p></li></ul><h4 id="实用宏" tabindex="-1"><a class="header-anchor" href="#实用宏"><span>实用宏</span></a></h4><ul><li><strong><code>LET(Var,Arg,Expr)</code></strong> - 在 <code>Expr</code> 中创建局部绑定 <code>Var = Arg</code>。这与 <code>(fun(Var)-&gt;(Expr)end)(Arg)</code> 相同。请注意，该绑定不会导出到 <code>Expr</code> 之外，并且在 <code>Expr</code> 中，<code>Var</code> 的此绑定将屏蔽外围作用域中任何 <code>Var</code> 的绑定。</li><li><strong><code>IF(Cond,TrueCase,FalseCase)</code></strong> - 如果 <code>Cond</code> 评估为 <code>true</code>，则评估 <code>TrueCase</code>，否则如果 <code>Cond</code> 评估为 <code>false</code>，则评估 <code>FalseCase</code>。 (这与 ) 注意，如果 <code>Cond</code> 不返回布尔值，则会出错。</li></ul><h4 id="断言宏" tabindex="-1"><a class="header-anchor" href="#断言宏"><span>断言宏</span></a></h4><ul><li><strong><code>assert(BoolExpr)</code></strong> - 评估表达式 <code>BoolExpr</code>，如果测试已启用。除非结果为 <code>true</code>，否则将生成一个信息性异常。如果没有异常，宏表达式的结果为原子 <code>ok</code>，并且丢弃 <code>BoolExpr</code> 的值。如果测试已禁用，宏将不会生成任何代码，除了原子 <code>ok</code>，并且不会评估 <code>BoolExpr</code>。</li><li><strong><code>assertNot(BoolExpr)</code></strong> - 等同于 <code>assert(not (BoolExpr))</code>。</li><li>** <code>assertMatch(GuardedPattern, Expr)</code> ** - 评估 <code>Expr</code> 并在测试启用时与 <code>GuardedPattern</code> 匹配，如果测试失败，将生成一个信息性异常</li><li><strong><code>assertNotMatch(GuardedPattern, Expr)</code></strong> - assertMatch 的逆操作，为了方便。</li><li><strong><code>assertEqual(Expect, Expr)</code></strong> - 评估表达式 <code>Expect</code> 和 <code>Expr</code> 并进行相等性比较，如果测试已启用。如果值不相等，将生成一个信息性的异常；</li><li><code>assertNotEqual(Unexpected, Expr)</code> - 与 assertEqual 的反向情况，方便使用。</li><li><strong><code>assertException(ClassPattern, TermPattern, Expr)</code></strong></li><li><strong><code>assertError(TermPattern, Expr)</code></strong></li><li><strong><code>assertExit(TermPattern, Expr)</code></strong></li><li><code>assertThrow(TermPattern, Expr)</code> - 评估 Expr，捕获任何异常并测试它是否匹配预期的 ClassPattern:TermPattern。如果匹配失败，或者 Expr 没有抛出异常，将生成一个信息性的异常；</li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>（请注意，这些宏还有一类对应的表达式，以下划线字符 &quot;<code>_</code>&quot; 开头，例如 <code>?_assert(BoolExpr)</code>，这些表达式会创建一个“测试对象”） 而不是立即执行测试。这相当于编写 ?_test(断言(BoolExpr))</p></div><h4 id="检查输出的宏" tabindex="-1"><a class="header-anchor" href="#检查输出的宏"><span>检查输出的宏</span></a></h4><ul><li><strong><code>capturedOutput</code></strong> - 当前测试用例中由 EUnit 捕获的输出，作为字符串。</li></ul><h4 id="运行外部命令的宏" tabindex="-1"><a class="header-anchor" href="#运行外部命令的宏"><span>运行外部命令的宏</span></a></h4><ul><li><p><strong><code>assertCmd(CommandString)</code></strong> - 如果启用测试，将执行 <code>CommandString</code> 作为外部命令。除非返回的状态值为 0，否则将生成一个信息性异常。如果没有异常，宏表达式的值为原子 <code>ok</code>。如果未启用测试，宏将不会生成任何代码，除了原子 <code>ok</code>，并且命令将不会被执行。</p></li><li><p><strong><code>assertCmdStatus(N, CommandString)</code></strong> - 与 <code>assertCmd(CommandString)</code> 类似 宏，但在返回的状态值不是 <code>N</code> 的情况下会生成一个异常。</p></li><li><p><strong><code>assertCmdOutput(Text, CommandString)</code></strong> - 如果测试启用，将 <code>CommandString</code> 作为外部命令运行。除非命令输出完全匹配指定的字符串 <code>Text</code>，否则将生成一个信息性的异常。请注意，输出在所有平台上都标准化为使用单一的换行符（LF）作为行分隔符。如果没有异常，宏表达式的返回结果是原子 <code>ok</code>。如果测试未启用，宏将不会生成任何代码，除了返回原子 <code>ok</code>，并且命令不会被执行。</p></li><li><p><strong><code>cmd(CommandString)</code></strong> - 将 <code>CommandString</code> 作为外部命令运行。除非返回的状态值为 0（表示成功），否则将生成一个信息性的异常；否则，宏表达式的返回结果是命令产生的输出，作为平坦的字符串。输出在所有平台上都标准化为使用单一的换行符（LF）作为行分隔符。</p></li></ul><h4 id="调试宏" tabindex="-1"><a class="header-anchor" href="#调试宏"><span>调试宏</span></a></h4><ul><li><strong><code>debugHere</code></strong> - 只打印一个标记，显示当前文件和行号。注意，这是一个无参数的宏。结果总是 <code>ok</code>。</li><li><strong><code>debugMsg(Text)</code></strong> - 输出消息 <code>Text</code>（可以是普通的字符串、IO 列表或只是原子）。结果总是 <code>ok</code>。</li><li><strong><code>debugFmt(FmtString, Args)</code></strong> - 这个函数像 <code>io:format(FmtString, Args)</code> 一样格式化文本，并像 <code>debugMsg</code> 一样输出。结果总是 <code>ok</code>。</li><li><strong><code>debugVal(Expr)</code></strong> - 打印 <code>Expr</code> 的源代码及其当前值。例如，<code>?debugVal(f(X))</code> 可能显示为 &quot;<code>f(X) = 42</code>&quot;。（大型项会被宏 <code>EUNIT_DEBUG_VAL_DEPTH</code> 截断到默认值 15 的深度，用户可以覆盖此默认值。）结果总是 <code>Expr</code> 的值，因此此宏可以包裹任何表达式，在启用调试编译时显示其值。</li><li><strong><code>debugVal(Expr, Depth)</code></strong> - 类似于 <code>debugVal(Expr)</code>，但会将术语裁剪到给定的深度后打印出来。</li><li><strong><code>debugTime(Text,Expr)</code></strong> - 打印 <code>Text</code> 和评估 <code>Expr</code> 的.wall 时钟时间。结果总是 <code>Expr</code> 的值，因此这是一个宏。 可以包裹在任何表达式周围，以显示代码运行时的值 编译时启用了调试功能。例如， <code>List1 = ?debugTime(&quot;sorting&quot;, lists:sort(List))</code> 可能会显示为 &quot;<code>排序: 0.015 秒</code>&quot;。</li></ul><h2 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h2>`,83)]))}const r=i(l,[["render",d]]),c=JSON.parse('{"path":"/backend/erlang/xm6fzrl5/","title":"实用工具","lang":"zh-CN","frontmatter":{"title":"实用工具","createTime":"2025/04/07 15:55:12","permalink":"/backend/erlang/xm6fzrl5/"},"headers":[],"readingTime":{"minutes":12.53,"words":3759},"git":{"updatedTime":1745926293000,"contributors":[{"name":"syh","username":"syh","email":"syh@qq.com","commits":3,"avatar":"https://gravatar.com/avatar/060d67e779a1b0aeace68a2a010b367f852e56888393383ea27302df983f6814?d=retro"}]},"filePathRelative":"notes/backend/erlang/erlang_foundation/tools.md"}');export{r as comp,c as data};
