import{_ as s,c as i,a,o as d}from"./app-C7T5jqfQ.js";const c={};function n(t,e){return d(),i("div",null,e[0]||(e[0]=[a(`<h2 id="引言" tabindex="-1"><a class="header-anchor" href="#引言"><span>引言</span></a></h2><p>在具有多个 Erlang 节点的分布式系统中，可能需要以分布式方式控制应用程序。如果某个应用程序所在的节点宕机，该应用程序需要在另一个节点上重新启动。</p><p>这样的应用程序称为<em>分布式应用程序</em>。请注意，是应用程序的控制权在分布式。所有应用程序都可以以分布式方式存在，例如，它们可以使用其他节点上的服务。</p><p>由于分布式应用程序可以在节点之间移动，因此需要某种地址机制，以确保其他应用程序可以在它当前执行的节点上对其进行地址定位。这个问题在此不作讨论，但可以使用内核中的<code>global</code>或<code>pg</code>模块来实现这一目的。</p><h2 id="指定分布式应用程序" tabindex="-1"><a class="header-anchor" href="#指定分布式应用程序"><span>指定分布式应用程序</span></a></h2><p>分布式应用程序由应用程序控制 控制器和一个名为分布式应用控制器进程的 <code>dist_ac</code>。这两个进程都是 Kernel 应用的一部分。因此，分布式应用是通过配置 Kernel 应用来指定的，使用以下配置参数（参见<a href="../../erlang_core/kernel/config">Kernel</a>）：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>distributed = [{Application, [Timeout,] NodeDesc}]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>指定应用<code>Application = 原子值()</code>可以执行的位置。</li><li><code>NodeDesc = [Node | {Node,...,Node}]</code> 是节点名称的列表，按优先级顺序排列。元组内的节点顺序是未定义的。</li><li><code>Timeout = 整数()</code> 指定在另一个节点重启应用前等待的毫秒数。默认值为 0。</li></ul><p>为了使分布式应用控制正常工作，分布式应用可以运行的节点必须相互联系并协商启动应用的位置。这通过内核中的以下配置参数完成：</p><ul><li><code>sync_nodes_mandatory = [Node]</code> - 指定必须在由 <code>sync_nodes_timeout</code> 指定的时间范围内启动的其他节点。</li><li><code>sync_nodes_optional = [Node]</code> - 指定可以启动的其他节点（等待时间由 sync_nodes_timeout 指定）。</li><li><code>sync_nodes_timeout = integer() | infinity</code> - 指定等待其他节点启动的毫秒数。</li></ul><p>启动时，节点会等待 sync_nodes_mandatory 指定的所有节点启动。 并且会在<code>sync_nodes_optional</code>后启动。当所有节点启动，或者所有必需节点启动并且<code>sync_nodes_timeout</code>指定的时间已经过去后，所有应用程序将启动。如果并非所有必需节点都启动，该节点将终止。</p><p><em>示例:</em></p><p>应用程序<code>myapp</code>将在节点<code>cp1@cave</code>上运行。如果该节点宕机， <code>myapp</code>将在<code>cp2@cave</code>或<code>cp3@cave</code>上重新启动。节点<code>cp1@cave</code>的系统配置文件<code>cp1.config</code>可以如下所示：</p><div class="language-erlang line-numbers-mode" data-highlighter="shiki" data-ext="erlang" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">[{</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">kernel</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  [{</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">distributed</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [{</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">myapp</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">cp1@cave</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">cp2@cave</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> cp3@cave</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}]}]},</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   {</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">sync_nodes_mandatory</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">cp2@cave</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> cp3@cave</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]},</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   {</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">sync_nodes_timeout</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 5000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  ]</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>cp2@cave</code>和<code>cp3@cave</code>的系统配置文件是相同的，除了强制节点列表，其值为<code>[cp1@cave, cp3@cave]</code> 对于<code>cp2@cave</code>，以及<code>[cp1@cave, cp2@cave]</code>对于<code>cp3@cave</code>。</p><h3 id="注意" tabindex="-1"><a class="header-anchor" href="#注意"><span>注意</span></a></h3><p>所有参与的节点必须具有相同的<code>distributed</code>值和<code>sync_nodes_timeou</code>t。否则，系统行为是未定义的。</p><h2 id="启动和停止分布式应用程序" tabindex="-1"><a class="header-anchor" href="#启动和停止分布式应用程序"><span>启动和停止分布式应用程序</span></a></h2><p>当所有涉及的（必需的）节点启动后，可以通过在<em>所有这些节点</em>调用 <code>application:start(Application)</code> 来启动分布式应用程序。</p><p>可以使用启动脚本（参见发布），该脚本可以自动启动应用程序。</p><p>该应用程序在列出在<code>distributed</code>配置参数中的第一个操作节点上启动。应用程序启动方式与通常相同，即创建一个应用程序主进程并调用应用程序回调函数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Module:start(normal, StartArgs)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>示例:</p><p>继续上一节中的示例，启动三个节点并指定系统配置文件：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>&gt; erl -sname cp1 -config cp1</span></span>
<span class="line"><span>&gt; erl -sname cp2 -config cp2</span></span>
<span class="line"><span>&gt; erl -sname cp3 -config cp3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当所有节点都处于运行状态时，可以启动<code>myapp</code>。这可以通过在三个节点上分别调用<code>application:start(myapp)</code>来实现。然后在所有节点上启动它。 cp1，如图所示：</p><p><img src="https://www.erlang.org/doc/system/assets/dist1.gif" alt="Application myapp - Situation 1"></p><p>同样地，必须通过调用 <code>application:stop(Application) </code>在所有涉及的节点上停止应用程序。</p><h2 id="故障转移" tabindex="-1"><a class="header-anchor" href="#故障转移"><span>故障转移</span></a></h2><p>如果运行应用程序的节点宕机，应用程序将在<code>distributed</code>配置参数中列出的第一个可操作节点上在指定超时后重新启动。这称为<em>故障转移</em>。</p><p>在新节点上，应用程序将通过应用程序主节点正常启动，即调用：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Module:start(normal, StartArgs)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>除非应用程序定义了<code>start_phases</code>键（参见 <a href="https://www.erlang.org/doc/system/included_applications" target="_blank" rel="noopener noreferrer">包含的应用程序</a>)。然后通过调用以下内容启动该应用程序：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Module:start({failover, Node}, StartArgs)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在这里，<code>Node</code> 是终止节点。</p><p><em>示例:</em></p><p>如果<code>cp1</code>宕机，系统会检查<code>cp2</code>或<code>cp3</code>中哪个节点运行的应用程序最少，但会等待 5 秒钟。 如果<code>cp1</code>没有重新启动，并且<code>cp2</code>运行的应用程序比<code>cp3</code>少，那么<code>myapp</code>将在<code>cp2</code>上重新启动。 如果<code>cp1</code>没有重新启动且<code>cp2</code>运行的应用程序比<code>cp3</code>少，<code>myapp</code>将在<code>cp2</code>上重新启动。</p><p><img src="https://www.erlang.org/doc/system/assets/dist2.gif" alt="Application myapp - Situation 2"></p><p>假设现在 <code>cp2</code> 也宕机，并且在 5 秒内没有重启。 <code>myapp</code> 现在在 <code>cp3</code> 上被重启。</p><p><img src="https://www.erlang.org/doc/system/assets/dist3.gif" alt="Application myapp - Situation 3"></p><h2 id="接管" tabindex="-1"><a class="header-anchor" href="#接管"><span>接管</span></a></h2><p>如果一个节点的优先级根据<code>distributed</code>高于运行分布式应用程序的节点，那么该应用程序将在新节点上重新启动并在旧节点上停止。这被称为 重新启动和停止。 restarted at the new node and stopped at the old node. This is called a <em>接管</em>.</p><p>应用程序由应用主进程启动，调用：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Module:start({takeover, Node}, StartArgs)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里 <code>Node</code> 是旧节点。</p><p><em>示例:</em></p><p>如果 <code>myapp</code> 在 <code>cp3</code> 上运行，而 <code>cp2</code> 现在重启，则不会重启 <code>myapp</code>，因为 <code>cp2</code> 和 <code>cp3</code> 节点之间的顺序是未定义的。 <code>myapp</code>，因为 <code>cp2</code> 和 <code>cp3</code> 节点之间的顺序是未定义的。</p><p><img src="https://www.erlang.org/doc/system/assets/dist4.gif" alt="Application myapp - Situation 4"></p><p>然而，如果<code>cp1</code>也重新启动，函数<a href="https://www.erlang.org/doc/apps/kernel/application#takeover/2" target="_blank" rel="noopener noreferrer"><code>application:takeover/2</code></a>会将 <code>myapp</code>移动到<code>cp1</code>，因为<code>cp1</code>在此应用程序中的优先级高于<code>cp3</code>。在这种情况下， <code>Module:start({takeover, cp3@cave}, StartArgs)</code> 会在<code>cp1</code>执行以启动该应用程序。</p><p><img src="https://www.erlang.org/doc/system/assets/dist5.gif" alt="Application myapp - Situation 5"></p>`,50)]))}const l=s(c,[["render",n]]),o=JSON.parse('{"path":"/backend/erlang/s1j82rn0/","title":"分布式应用程序","lang":"zh-CN","frontmatter":{"title":"分布式应用程序","createTime":"2025/03/22 15:24:39","permalink":"/backend/erlang/s1j82rn0/"},"headers":[],"readingTime":{"minutes":5.11,"words":1532},"git":{"updatedTime":1745841107000,"contributors":[{"name":"舒永好","username":"舒永好","email":"shuyonghao@guoshenghuaxing.com","commits":1,"avatar":"https://gravatar.com/avatar/4b1c3f37ea707968be73c631a79de33afd360724ce87bf8f9dcacd67d14df92c?d=retro"},{"name":"syh","username":"syh","email":"syh@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/060d67e779a1b0aeace68a2a010b367f852e56888393383ea27302df983f6814?d=retro"}]},"filePathRelative":"notes/backend/erlang/erlang_otp/design_rule/distributed_application.md"}');export{l as comp,o as data};
