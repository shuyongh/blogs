import{_ as i,c as a,a as n,o as p}from"./app-C7T5jqfQ.js";const l="/blogs/assets/image-20250409190740261-DCzOmd64.png",t="/blogs/assets/image-20250409190800297-BulZ8gvA.png",h="/blogs/assets/image-20250409190819647-BawqO9uZ.png",k="/blogs/assets/image-20250409190835524-1Gt35OvT.png",e="/blogs/assets/image-20250409190854902-u2rqHuoE.png",g="/blogs/assets/image-20250409190912823-D8e8wUjs.png",r="/blogs/assets/image-20250409191106158-DIc-ZV_S.png",d="/blogs/assets/image-20250409191134029-CBLLh9ne.png",o="/blogs/assets/image-20250409191233573-CTICsJn1.png",c="/blogs/assets/image-20250409191252505-qAnpspYi.png",m="/blogs/assets/image-20250409191322740-CCfpP4Av.png",y="/blogs/assets/image-20250409191345003-D9xAZfL6.png",A={};function b(B,s){return p(),a("div",null,s[0]||(s[0]=[n('<h2 id="何为路径规划" tabindex="-1"><a class="header-anchor" href="#何为路径规划"><span>何为路径规划？</span></a></h2><p>首先，我们简单了解下运动规划问题：在给定的位置A与位置B之间为机器人找到一条符合约束条件的路径。这种问题常出现在机器人、汽车导航等工业应用中。而路径规划则是运动规划里的重要研究内容。</p><p>所谓路径规划，就是指在一张已知的地图上，规划出一条位置A到位置B的路径。而运动规划里也有很多不知地图的情形，需要机器人自主去构建地图、自主摸索规划路径。</p><p>而对于游戏程序的运动规划问题，更多（甚至绝大部分）都是路径规划问题，因为游戏地图几乎总是已知的。因此本文主要列举一些可用于游戏程序的路径规划知识</p><h2 id="寻路算法" tabindex="-1"><a class="header-anchor" href="#寻路算法"><span>寻路算法</span></a></h2><h3 id="dijkstra算法" tabindex="-1"><a class="header-anchor" href="#dijkstra算法"><span>Dijkstra算法</span></a></h3><p>经典的图算法，直接运用在游戏AI的寻路中效率会非常低，因此这里就不多说明了。</p><h3 id="a-寻路算法" tabindex="-1"><a class="header-anchor" href="#a-寻路算法"><span>A*寻路算法</span></a></h3><blockquote><p>从某个起点到某个终点通常使用深度优先搜索（DFS），DFS搜索的搜索方向一般是8个方向（如果不允许搜索斜向，则有4个），但是并无优先之分。</p><p>为了让DFS搜索更加高效，结合贪心思想，我们给搜索方向赋予了优先级，直观上离终点最近的方向（直观上的意思是无视障碍物的情况下）为最优先搜索方向，这就是A*算法。</p></blockquote><h4 id="步骤" tabindex="-1"><a class="header-anchor" href="#步骤"><span>步骤</span></a></h4><p>（如下图，绿色为起点，红色为终点，蓝色为不可通过的墙。）</p><p><img src="'+l+'" alt="image-20250409190740261"></p><p>从起点开始往四周各个方向搜索。</p><p>（这里的搜索方向有8个方向）</p><p><img src="'+t+'" alt="image-20250409190800297"></p><p>为了区分搜索方向的优先级，我们给每个要搜索的点赋予2个值。</p><p><strong>G值（耗费值）：指从起点走到该点要耗费的值。</strong></p><p><strong>H值（预测值）：指从该点走到终点的预测的值（从该点到终点无视障碍物情况下预测要耗费的值，也可理解成该点到终点的直线距离的值）</strong></p><p>在这里，值 = 要走的距离</p><p>（实际上，更复杂的游戏，因为地形不同（例如陷阱，难走的沙地之类的），还会有相应不同的权值：值 = 要走的距离 * 地形权值）</p><p>我们还定义直着走一格的距离等于10，斜着走一格的距离等于14（因为45°斜方向的长度= sqrt(10<sup>2+10</sup>2) ≈ 14）</p><p><strong>F值（优先级值）：F = G + H</strong></p><p>这条公式意思：F是从起点经过该点再到达终点的预测总耗费值。通过计算F值，我们可以优先选择F值最小的方向来进行搜索。</p><p>（每个点的左上角为F值，左下角为G值，右下角为H值）</p><p><img src="'+h+'" alt="image-20250409190819647"></p><p>计算出每个方向对应点的F,G,H值后，</p><p>还需要给这些点赋予<strong>当前节点的指针值</strong>（用于回溯路径。因为一直搜下去搜到终点后，如果没有前一个点的指针，我们将无从得知要上次经过的是哪个点，只知道走到终点最终耗费的最小值是多少）</p><p>然后我们将这些点放入<strong>openList(开启列表：用于存放可以搜索的点)</strong></p><p>然后再将当前点放入<strong>closeList(关闭列表：用于存放已经搜索过的点，避免重复搜索同一个点)</strong></p><p>然后再从openList取出一个F值最小（最优先方向）的点，进行上述同样的搜索。</p><p><img src="'+k+'" alt="image-20250409190835524"></p><p>在搜索过程中，如果搜索方向上的点是障碍物或者关闭列表里的点，则跳过之。</p><p>通过递归式的搜索，多次搜索后，最终搜到了终点。</p><p><img src="'+e+'" alt="image-20250409190854902"></p><p>搜到终点后，然后通过前一个点的指针值，我们便能从终点一步步回溯通过的路径点。</p><p>（红色标记了便是回溯到的点）</p><p><img src="'+g+'" alt="image-20250409190912823"></p><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><img src="'+r+'" alt="image-20250409191106158"></p><h3 id="b-寻路算法" tabindex="-1"><a class="header-anchor" href="#b-寻路算法"><span>B*寻路算法</span></a></h3><p>在写A<em>寻路算法总结笔记的时候，我还偶然发现了另一个号称效率更高的B</em>的算法，而且看了定义以后，发现概念也很简单。</p><p>B*算法类似于水往低处流的思路：</p><ol><li>直接往目标点移动，若遇到障碍则尝试绕爬。</li><li>绕开后重复上述步骤。</li></ol><p>该算法的确效率很高，但是它的路径结果往往不是最优的（当然非最优解的路径也适用于游戏AI，因为这能让玩家觉得AI路径自然。）</p><p>然而致命的是，当障碍物是凹多边形时（凹口朝向与玩家的探索方向相反时），B*算法很难实现绕爬出来，从而导致无解。</p><p>而网上资料展示的障碍往往没有提到这种障碍情况（绕爬需要至少两格宽度，而图示只有一格宽度，不可绕爬只可退步）</p><p><img src="'+d+'" alt="image-20250409191134029"></p><p>一种解决方法是回溯绕爬，即限制最多可回退若干个节点，每次回退尝试一次绕爬，直到一次绕爬成功。 但是要是允许回溯过多节点，其复杂度会退化成DFS的程度，丧失了其效率高的特性。</p><p>总之，B*算法其实就是暴力的直觉寻路，它可能适合简单障碍的地图并且所需寻路不用较好的解或者不需要知道地图信息的无脑尝试绕爬的行为。综上，其实并不多可能运用于游戏开发中的路径规划中。</p><h3 id="jps寻路算法" tabindex="-1"><a class="header-anchor" href="#jps寻路算法"><span>JPS寻路算法</span></a></h3><blockquote><p>JPS（jump point search）算法实际上是对A* 寻路算法的一个改进，因此在阅读本文之前需要先了解A<em>算法。A</em> 算法在扩展节点时会把节点所有邻居都考虑进去，这样openlist中点的数量会很多，搜索效率较慢。</p></blockquote><p>例如在无遮挡情况下（往往会有多条等价路径），而我们希望起点到终点实际只取其中一条路径，而该路径外其它节点可以没必要放入openlist（不希望加入没必要的邻居）</p><p><img src="'+o+'" alt="image-20250409191233573"></p><p>其次我们还希望直线方向上中途的点不用放入openlist，如果只放入每段直线子路径的起点和终点，那openlist又可以少放很多没必要的节点：</p><p><img src="'+c+'" alt="image-20250409191252505"></p><blockquote><p>可以看到 JPS 算法搜到的节点总是“跳跃性”的，这是因为这些关键性的节点都是需要改变行走方向的拐点，因此这也是 Jump Point 命名的来历。</p></blockquote><p>在介绍JPS等算法具体实现前，我们必须先掌握下面的概念。</p><h4 id="强迫邻居-forced-neighbour" tabindex="-1"><a class="header-anchor" href="#强迫邻居-forced-neighbour"><span>强迫邻居（Forced Neighbour）</span></a></h4><p>强迫邻居：节点 x 的8个邻居中有障碍，且 x 的父节点 p 经过x 到达 n 的距离代价比不经过 x 到达的 n 的任意路径的距离代价小，则称 n 是 x 的强迫邻居。</p><blockquote><p>看定义也许十分晦涩难懂。直观来说，实际就是因为前进方向（父节点到 x 节点的方向为前进方向）的某一边的靠后位置有障碍物，因此想要到该边靠前的空位有最短的路径，就必须得经过过 x 节点。</p></blockquote><p>可能的情况见图示，黑色为障碍，红圈即为强迫邻居：</p><p><img src="'+m+'" alt="image-20250409191322740"></p><p>（左图为直线方向情况下的强迫邻居，右图为斜方向情况下的强迫邻居）</p><h4 id="跳点-jump-point" tabindex="-1"><a class="header-anchor" href="#跳点-jump-point"><span>跳点（Jump Point）</span></a></h4><p>跳点：当前点 x 满足以下三个条件之一：</p><ul><li>节点 x 是起点/终点。</li><li>节点 x 至少有一个强迫邻居。</li><li>如果父节点在斜方向（意味着这是斜向搜索），节点x的水平或垂直方向上有满足条件a，b的点。</li></ul><blockquote><p>节点y的水平或垂直方向是斜向向量的拆解，比如向量d=(1,1)，那么水平方向则是(1,0)，并不会往左搜索，只会看右边，如果向量d=(-1,-1)，那么水平方向是(-1,0)，只会搜索左边，不看右边，其他同理。</p></blockquote><p>下图举个例子，由于黄色节点的父节点是在斜方向，其对应分解成向上和向右两个方向，因为在右方向发现一个蓝色跳点，因此黄色节点也应被判断为跳点：</p><p><img src="'+y+`" alt="image-20250409191345003"></p><h4 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h4><p>JPS 算法和A* 算法非常相似，步骤大概如下：</p><ol><li>openlist取一个权值最低的节点，然后开始搜索。（这些和A*是一样的）</li><li>搜索时，先进行 <strong>直线搜索</strong>（4/8个方向，跳跃搜索），然后再 <strong>斜向搜索</strong>（4个方向，只搜索一步）。如果期间某个方向搜索到跳点或者碰到障碍（或边界），则当前方向完成搜索，若有搜到跳点就添加进openlist。</li></ol><blockquote><p>跳跃搜索是指沿直线方向一直搜下去（可能会搜到很多格），直到搜到跳点或者障碍（边界）。一开始从起点搜索，会有4个直线方向（上下左右），要是4个斜方向都前进了一步，此时直线方向会有8个。</p></blockquote><ol><li>若斜方向没完成搜索，则斜方向前进一步，重复上述过程。</li></ol><blockquote><p>因为直线方向是跳跃式搜索，所以总是能完成搜索。</p></blockquote><ol><li>若所有方向已完成搜索，则认为当前节点搜索完毕，将当前节点移除于openlist，加入closelist。</li><li>重复取openlist权值最低节点搜索，直到openlist为空或者找到终点。</li></ol><p>下面结合图片更好说明过程2和3：首先我们从openlist取出绿色的节点，作为搜索的开始，先进行直线搜索，再斜向搜索，没有找到任何跳点。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210114034-1368982441.png" alt="img"></p><p>斜方向前进一步后，重复直线搜索和斜向搜索过程，仍没发现跳点。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210116214-769239964.png" alt="img"></p><p>斜方向前进两步后，重复直线搜索和斜向搜索过程，仍没发现跳点。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210118414-967365132.png" alt="img"></p><p>斜方向前进了三步后（假设当前位置为 x），在水平直线搜索上发现了一个跳点（紫色节点为强迫邻居）。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210120811-72527475.png" alt="img"></p><p>于是 x 也被判断为跳点，添加进openlist。斜方向结束，绿色节点的搜索过程也就此结束，被移除于openlist，放入closelist。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210123661-592659677.png" alt="img"></p><h4 id="示例过程" tabindex="-1"><a class="header-anchor" href="#示例过程"><span>示例过程</span></a></h4><p>下面展示JPS算法更加完整的过程：</p><p>假设起点为绿色节点，终点为红色节点。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210126180-1026210938.png" alt="img"></p><p>重复直线搜索和斜向搜索过程，斜方向前进了3步。在第3步判断出黄色节点为跳点（依据是水平方向有其它跳点），将黄色跳点放入openlist，然后斜方向搜索完成，绿色节点移除于openlist，放入closelist。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210139878-616619718.png" alt="img"></p><p>对openlist下一个权值最低的节点（即黄色节点）开启搜索，在直线方向上发现了蓝色节点为跳点（依据是紫色节点为强迫邻居），类似地，放入openlist。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210142878-1378535322.png" alt="img"></p><p>由于斜方向还没结束，继续前进一步。最后一次直线搜索和斜向搜索都碰到了边界，因此黄色节点搜索完成，移除于openlist，放入closelist。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210145026-267059363.png" alt="img"></p><p>对openlist下一个权值最低的节点（原为蓝色节点，下图变为黄色节点）开启搜索，直线搜索碰到边界，斜向搜索无果。斜方继续前进一步，仍然直线搜索碰到边界，斜向搜索无果。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210147043-958207734.png" alt="img"></p><p>由于斜方向还没结束，继续前进一步。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210149169-693297504.png" alt="img"></p><p>最终在直线方向上发现了红色节点为跳点，因此蓝色节点先被判断为跳点，只添加蓝色节点进openlist。斜方向完成，黄色节点搜索完成。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200616210151486-448555628.png" alt="img"></p><p>最后openlist取出的蓝色节点开启搜索，在水平方向上发现红色节点，判断为终点，算法完成。</p><blockquote><p>回忆起跳点的第三个判断条件（如果父节点在斜方向，节点x的水平或垂直方向上有满足条件a，b的点），会发现这个条件判断是最复杂的。在寻路过程中，它使寻路多次在水平节点上搜到跳点，也只能先添加它本身。其次，这也是算法中需要使用到递归的地方，是JPS算法性能瓶颈所在。</p></blockquote><h3 id="jps-jump-point-search-plus" tabindex="-1"><a class="header-anchor" href="#jps-jump-point-search-plus"><span>JPS+（Jump Point Search Plus）</span></a></h3><hr><p>JPS+ 本质上也是 JPS寻路，只是加上了预处理来改进，从而使寻路更加快速。</p><h4 id="预处理" tabindex="-1"><a class="header-anchor" href="#预处理"><span>预处理</span></a></h4><p>我们首先对地图每个节点进行跳点判断，找出所有主要跳点：</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617021040905-1975582874.png" alt="img"></p><p>然后对每个节点进行跳点的直线可达性判断，并记录好跳点直线可达性：</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617021042490-203165445.png" alt="img"></p><p>若可达还需记录号跳点直线距离：</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617021045421-747799641.png" alt="img"></p><p>类似地，我们对每个节点进行跳点斜向距离的记录：</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617021047283-308530179.png" alt="img"></p><p>剩余各个方向如果不可到达跳点的数据记为0或负数距离。如果在对应的方向上移动1步后碰到障碍（或边界）则记为0，如果移动n+1步后会碰到障碍（或边界）的数据记为负数距离-n</p><p>最后每个节点的8个方向都记录完毕，我们便完成了JPS+的预处理过程：</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617021053071-587803294.png" alt="img"></p><p>以上预处理过程需要有一个数据结构存储地图上每个格子8个方向距离碰撞或跳点的距离。</p><h4 id="示例过程-1" tabindex="-1"><a class="header-anchor" href="#示例过程-1"><span>示例过程</span></a></h4><p>做好了地图的预处理之后，我们就可以使用JPS+算法了。大致思路与JPS算法相同，不过这次有了预处理的数据，我们可以更快的进行<strong>直线搜索</strong>和<strong>斜向搜索</strong>。</p><p>在某个搜索方向上有：</p><ul><li>对于正数距离 n（意味着距离跳点 n 格），我们可以直接将n步远的节点作为跳点添加进openlist</li><li>对于0距离（意味着一步都不可移动），我们无需在该方向搜索；</li><li>对于负数距离 -n（意味着距离边界或障碍 n 格），我们直接将n步远的节点进行一次跳点判断（有可能满足跳点的第三条件，不过得益于预处理的数据，这步也可以很快完成）。</li></ul><p>如下图示，起始节点通过已记录的向上距离，直接将3步远的跳点添加进openlist，而不再像以前需要迭代三步（还每步都要判断是否跳点）：</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617022118864-96776303.png" alt="img"></p><p>其它过程也是类似的：</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617022120311-1442950995.png" alt="img"><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617022122431-1103041540.png" alt="img"><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617022124185-457422021.png" alt="img"><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200617022126443-867450622.png" alt="img"></p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><hr><p>可以看到 JPS/JPS+ 算法里只有跳点才会被加入openlist里，排除了大量不必要的点，最后找出来的最短路径也是由跳点组成。这也是 JPS/JPS+ 高效的主要原因。</p><p><strong>JPS</strong> ：</p><ul><li>绝大部分地图，使用 JPS 算法都会比 A* 算法更快，内存占用也更小（openlist里节点少了很多）。</li><li>JPS 在跳点判断上，要尽可能避免递归的深度过大（或者期待一下以后出现避免递归的算法），否则在超大型的地图里递归判断跳点可能会造成灾难。</li><li>JPS 也可以用于动态变化的地图，只是每次地图改变都需要再进行一次 JPS 搜索。</li><li>JPS 天生拥有合并节点（亦或者说是在一条直线里移除中间不必要节点）的功能，但是仍存在一些可以继续合并的地方。</li><li>JPS 只适用于 网格（grid）节点类型，不支持 Navmesh 或者路径点(Way Point)。</li></ul><p><strong>JPS+</strong> ：</p><ul><li>JPS+ 相比 JPS 算法又是更快上一个档次（特别是避免了过多层递归判断跳点），内存占用则是每个格子需要额外记录8个方向的距离数据。</li><li>JPS+ 算法由于包含预处理过程，这让它面对动态变化的地图有天生的劣势（几乎是不可以接受动态地图的），因此更适合用于静态地图。</li><li>JPS+ 预处理的复杂度为 O(n)O(n) ，n 代表地图格子数。</li></ul><table><thead><tr><th>算法</th><th>性能</th><th>内存占用</th><th>支持动态地图</th><th>预处理</th><th>支持节点类型</th></tr></thead><tbody><tr><td>A*</td><td>中等</td><td>大</td><td>支持</td><td>无</td><td>网格、Navmesh、路径点</td></tr><tr><td>JPS</td><td>快</td><td>小</td><td>支持</td><td>无</td><td>网格</td></tr><tr><td>JPS+</td><td>非常快</td><td>大</td><td>不支持</td><td>有，O(n)O(n)</td><td>网格</td></tr></tbody></table><p>综上，JPS/JPS+ 是A<em>算法的优秀替代者，绝大部分情况下更快和更小的内存占用已经足够诱人。在GDC 2015 关于 JPS+ 算法的演讲中，Steve Rabin 给出的数据甚至是比A</em> 算法快70~350倍。</p><h3 id="d-寻路算法" tabindex="-1"><a class="header-anchor" href="#d-寻路算法"><span>D*寻路算法</span></a></h3><p>对于一些静态的游戏场景来说，A<em>算法是很好的选择。但是如果障碍是动态的，例如移动的车辆堵住了路...A</em>算法可能得时时重新计算路径才能保证适应动态场景，这开销无疑是巨大的。而D*寻路算法正是用于解决动态障碍场景问题的一种寻路算法。</p><h2 id="寻路节点" tabindex="-1"><a class="header-anchor" href="#寻路节点"><span>寻路节点</span></a></h2><h3 id="使用路径点-way-point-作为节点" tabindex="-1"><a class="header-anchor" href="#使用路径点-way-point-作为节点"><span>使用路径点（Way Point）作为节点</span></a></h3><p>大部分讨论A<em>算法使用的节点是网格点（也就是简单的二维网格），但是这种内存开销往往比较大。 实际上A</em>寻路算法，对于图也是适用的，实现只要稍微改一下。</p><p>因此我们可以把地图看作一个图而不是一个网格，使用预先设好的路径点而不是网格来作为寻路节点，则可以减少大量节点数量。</p><p><img src="https://img2018.cnblogs.com/blog/1409576/201904/1409576-20190414121324221-1974570000.png" alt="img"></p><p>（如图，使用了路径点作为节点，路径点之间的连线表示两点之间可直接移动穿过）</p><p>使用路径点的好处：</p><ul><li>减少大量节点数量，顺带也就减少了寻路的运算速度开销。</li><li>相比网格节点，路径点的路径更加平滑。</li></ul><h3 id="多层次路径点" tabindex="-1"><a class="header-anchor" href="#多层次路径点"><span>多层次路径点</span></a></h3><p>在育碧的游戏《Assassin&#39;s Creed: Origins》里，地图大的令人发指（也许有整个埃及地区的大小）。而大地图的寻路是一种比较头疼的问题。为了实现长距离导航(Long range navigation)，地图采用了路径点作为节点，同时采用了三层次节点的划分。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200614081634393-55601246.png" alt="img"></p><p>寻路首先是发生在最高层次上（图为黄色部分节点），需要先找到离玩家最近的和离终点最近的黄色层次节点。</p><p>然后根据找到的2个节点，在它们的所属区块里再寻找离玩家/终点最近的绿色层次节点，从而找到绿色节点到达黄色节点的方法。</p><p>同理，在2个绿色层次节点所属区块（更小的区块）寻找离玩家/终点最近的白色层次节点。</p><p>最后找到的三个层次节点相连接，便是一条长距离导航路径。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200614080744460-141560378.png" alt="img"></p><h3 id="使用导航网格-navigation-mesh-作为节点" tabindex="-1"><a class="header-anchor" href="#使用导航网格-navigation-mesh-作为节点"><span>使用导航网格（Navigation Mesh）作为节点</span></a></h3><p><img src="https://img2018.cnblogs.com/blog/1409576/201909/1409576-20190912160530139-1749088664.jpg" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1409576/201909/1409576-20190912160155838-1488741446.png" alt="img"></p><p>导航网格将地图划分成若干个凸多边形，每个凸多边形就是一个节点。 使用导航网格更加可以大大减少节点数量，从而减少搜寻所需的计算量，同时也使路径更加自然。</p><p><img src="https://img2018.cnblogs.com/blog/1409576/201901/1409576-20190129195751058-1433756046.png" alt="img"></p><blockquote><p>使用凸多边形，是因为凸多边形有一个很好的特性：边上的一个点走到另外一点，不管怎么走都不会走出这个多边形。而凹多边形可能走的出外面。</p></blockquote><p>然而该如何建立地图的导航网格，一般有两种方法：</p><ul><li>手工划分导航网格往往工作量巨大。</li><li>程序化生成导航网格则实现稍微复杂。</li></ul><h2 id="预计算" tabindex="-1"><a class="header-anchor" href="#预计算"><span>预计算</span></a></h2><hr><p>主要方式是通过预先计算好的数据，然后运行时使用这些数据减少运算量。 可以根据自己的项目权衡运行速度和内存空间来选择预计算。</p><h3 id="洪水填充法-floodfill-自动创建路径点" tabindex="-1"><a class="header-anchor" href="#洪水填充法-floodfill-自动创建路径点"><span>洪水填充法（Floodfill）自动创建路径点</span></a></h3><p>倘若一个地图过大，开发人员手动预设好路径点+路径连接的工作就比较繁琐，而且很容易有错漏。 这时可以使用洪水填充算法来自动生成路径点，并为它们链接。</p><p>算法步骤： 1.以任意一点为起始点，往周围八个方向扩展点（不能通行的位置则不扩展）</p><p><img src="https://img2018.cnblogs.com/blog/1409576/201904/1409576-20190414003022032-1357610547.jpg" alt="img"></p><p>2.已经扩展的点（在图中被标记成红色）不需要再次扩展，而扩展出来新的点继续扩展</p><p><img src="https://img2018.cnblogs.com/blog/1409576/201904/1409576-20190414003149750-1592868242.jpg" alt="img"></p><p>3.直到所有的点都被扩展过，此时能得到一张导航图</p><p><img src="https://img2018.cnblogs.com/blog/1409576/201904/1409576-20190414003207394-926760424.jpg" alt="img"></p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//洪水填充法:从一个点开始自动生成导航图</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> generateWayPoints</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> beginx</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> beginy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">vector</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">WayPoint</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> points</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//需要探索的点的列表</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">	std</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">::</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">queue</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">WayPoint</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pointsToExplore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//生成起点，若受阻，不能生成路径点，则退出</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">	if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">canGeneratePointIn</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">beginx</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> beginy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">	points</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">emplace_back</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WayPoint</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">beginx</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> beginy</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//扩展距离</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	float</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> distance </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2.3</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">f</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//预先写好8个方向的增量</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> direction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">8</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">][</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">},</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">},</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">},</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">},</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">},</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">},</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">},{</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> };</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//以起点开始探索</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">	WayPoint</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> begin </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">points</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">back</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">	pointsToExplore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">emplace</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">begin</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//重复探索直到探索点列表为空</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">	while</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">pointsToExplore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">empty</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">		//先取出一个点开始进行探索</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">		WayPoint</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> point </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> pointsToExplore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">front</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">		pointsToExplore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">pop</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">		//往8个方向探索</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">		for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 8</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ++</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">			//若当前点的目标方向连着点，则无需往这方向扩展</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">			if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">point</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">pointInDirection</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> ==</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> nullptr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">				continue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">			}</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">			auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> x </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> point</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">x</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> direction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">][</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> distance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">			auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> y </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> point</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">-&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">y</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> direction</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">][</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> distance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">			//如果目标位置受阻，则无需往这方向扩展</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">			if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">!</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">canGeneratePointIn</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">x</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> y</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">				continue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">			}</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">			points</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">emplace_back</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">WayPoint</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">x</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> y</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">			auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> newPoint </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">points</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">back</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">			pointsToExplore</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">emplace</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">newPoint</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">			//如果当前点能够无障碍通向目标点，则连接当前点和目标点</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">			if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">canWalkTo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">point</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> newPoint</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">				point</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">connectToPoint</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">newPoint</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">			}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">		}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自动生成的导航图可以调整扩展的距离，从而得到合适的节点和边的数量。同时也可以调整扩展方向，再加入一定随即噪音作为距离和方向的参数，可以实现随机扩展的效果，从而得到更加自然的路径。</p><h3 id="路径查询表-路径成本查询表" tabindex="-1"><a class="header-anchor" href="#路径查询表-路径成本查询表"><span>路径查询表/路径成本查询表</span></a></h3><p><img src="https://img2018.cnblogs.com/blog/1409576/201904/1409576-20190413235909288-1510454514.png" alt="img"></p><p>借助预先计算好的路径查询表，可以以O(|v|)的时间复杂度极快完成寻路，但是占用空间为O(|v|²)。 （|v|为顶点数量）</p><p><img src="https://img2018.cnblogs.com/blog/1409576/201902/1409576-20190201182934842-784810467.png" alt="img"></p><p><strong>实现</strong>：对每个顶点使用Dijkstra算法，求出该顶点到各顶点的路径，再通过对路径回溯得到前一个经过的点。</p><p>有时候，游戏AI需要考虑路径的成本来决定行为， 则可以预先计算好路径成本查询表，以O（1）的时间复杂度获取路径成本，但是占用空间为O(|v|²)。</p><p><img src="https://img2018.cnblogs.com/blog/1409576/201902/1409576-20190201182938608-273577879.png" alt="img"></p><p><strong>实现</strong>：类似路径查询表，只不过记录的是路径成本开销，而不是路径点。</p><h3 id="扩展障碍碰撞几何体" tabindex="-1"><a class="header-anchor" href="#扩展障碍碰撞几何体"><span>扩展障碍碰撞几何体</span></a></h3><p><img src="https://img2018.cnblogs.com/blog/1409576/201909/1409576-20190911110344478-1380751058.png" alt="img"></p><p>在寻路中，一个令游戏AI程序员头疼的问题是碰撞模型往往是一个几何形状而不是一个点。 这意味着在寻路时检测是否碰到障碍，得用几何形状与几何形状相交判断，而非几何形状包含点判断（毋庸置疑前者开销庞大）。</p><p>一个解决方案是根据碰撞模型的形状扩展障碍几何体，此时碰撞模型可以简化成一个点，这样可以将问题由几何形状与几何形状相交问题转换成几何形状包含点问题。</p><p>这里主要由两种扩展思路：</p><ul><li>碰撞模型的各个顶点与障碍几何体顶点重合，然后扫过去锚点形成的边界即是扩展的边界（实际上就是让碰撞模型紧挨着障碍几何体走一圈）</li></ul><p><img src="https://img2018.cnblogs.com/blog/1409576/201909/1409576-20190911110355305-1916157604.png" alt="img"></p><ul><li>碰撞模型的锚点与障碍几何体顶点重合，然后扫过去最外围顶点形成的边界即是扩展的边界（实际上就是让碰撞模型沿着原几何体边界走一圈）</li></ul><p><img src="https://img2018.cnblogs.com/blog/1409576/201909/1409576-20190911110401921-2004782764.png" alt="img"></p><p>这些扩展障碍几何形状的计算完全可以放到预计算（离线计算），不过要注意：</p><ul><li>各个需要寻路的碰撞模型最好统一形状，这样我们只需要记录一张（或少量）扩展过的障碍图。</li><li>碰撞模型不可以是圆形，因为这样扩展出的障碍几何体将是圆曲的，很难计算。一个解决方案是用正方形近似替代圆形来生成扩展障碍几何体。</li><li>当遇到非凸多边形障碍时，在凹处可能会出现扩展出的顶点重复（交点），简单的处理是凹角处不插入新的点。</li></ul><h3 id="goal-bounding" tabindex="-1"><a class="header-anchor" href="#goal-bounding"><span>Goal Bounding</span></a></h3><p>Goal Bounding是一种节点裁剪技术，可加快寻路速度。Goal Bounding为每个节点的边（Edge）计算一个节点集合，该集合至少包含通过该边可到达最短路的所有节点。</p><p>为了让节点集合支持快速查询是否含有目标节点的功能，往往需要使用特定形状表示集合（例如用4个int值来表示轴对齐的AABB盒），这也使得该集合包含了一定数量的无关节点。因此，用于Goal Bounding技术的节点集合也被称为Goal Bounds。</p><p>下图图示，左侧为绿色节点通过左边可达最短路径的所有节点，右侧为绿色节点计算出来的通过左边的Goal Bounds：</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200618194604035-941895451.png" alt="img"></p><p>下图图示，为使用NavMesh节点时计算出的Goal Bounds，NavMesh 天生具有不规则的形状，幸好AABB盒仍然能很好的表示集合，只是会有更多多余的无关节点。</p><p><img src="https://img2020.cnblogs.com/blog/1409576/202006/1409576-20200618150605841-741975111.png" alt="img"></p><ul><li>在通过某个边缘（即朝某个方向）搜索时，只有目标节点包含在通过该边的节点集合时，才会搜索该方向，否则该方向没必要搜索。</li><li>Goal Bounding 可以使用在任何寻路算法（Dijkstra、A*、JPS+等）应用于任何搜索空间（网格，图形，NavMesh等）。</li><li>Goal Bounding 的缺点在于必须使用O(n2)O(n2)时间对 Goal Bounding 数据进行预处理，因此无法支持对搜索空间进行动态运行时修改（添加或删除边/墙）。其次，Goal Bounding 要求O(n)O(n)的存储空间（Goal Bounds形状为AABB盒且地图为网格时，每个节点有8个边，每个边需要存储4个值，即总共 32n32n 个值）。</li></ul><p>对某个节点计算Goal Bounds的大致过程如下（以A*算法、网格地图、8方向为例）：</p><ol><li>从该节点出发，先朝八个方向各移动一格，将8个方向移动后的位置记录在对应的8个队列里。（这一步是为了保证搜索通过了目标方向。）</li><li>8个队列进行一轮移动：每个队列取出队首节点后，从该节点向8个方向移动一格。每移动到新的位置则记录在集合里，重复走过的位置（若是本轮中其它队列走过的位置，则依然视为本队列的新位置）则不需再记录。此外，每个队列每个取出过的节点需放入对应的集合（8个集合）。</li><li>重复步骤2，直到八个队列都为空，这意味着无论哪个方向都走到了尽头（边界或障碍）。</li><li>对其中一个集合进行遍历，提取出其中最大、最小的y值和最大、最小的x值，这个便作为Goal Bounds的AABB形状的表示。此时便代表本节点的一个方向的Goal Bounds计算完毕。</li><li>重复步骤4，直到本节点八个方向的Goal Bounds都计算完毕。</li></ol><p>在 GDC 2015 JPS+ with Goal Bounding的演讲上，Steve Rabin 给出了结合 JPS+ 和 Goal Bounding 的方案，效果非常好。</p>`,207)]))}const u=i(A,[["render",b]]),v=JSON.parse('{"path":"/game/w8g58e74/","title":"路径规划","lang":"zh-CN","frontmatter":{"title":"路径规划","createTime":"2025/04/09 18:05:05","permalink":"/game/w8g58e74/"},"headers":[],"readingTime":{"minutes":24.21,"words":7264},"git":{"updatedTime":1744200192000,"contributors":[{"name":"syh","username":"syh","email":"syh@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/060d67e779a1b0aeace68a2a010b367f852e56888393383ea27302df983f6814?d=retro"}]},"filePathRelative":"notes/game/ai/path_planning.md"}');export{u as comp,v as data};
