import{_ as a,c as s,a as i,o as l}from"./app-C7T5jqfQ.js";const t="/blogs/assets/image-20230928165711499-19smIGh1.png",p="/blogs/assets/image-20230514115450022-DuKdrFUe.png",n="/blogs/assets/image-20230928165917418-BYIY83Hp.png",o="/blogs/assets/image-20230514120131233-DQMxF2_q.png",r="/blogs/assets/image-20230514120151837-CcAxiPWt.png",g="/blogs/assets/image-20230927164932993-ZOqFtpML.png",m="/blogs/assets/image-20230927164948472-CcZLej1L.png",c="/blogs/assets/image-20230514120233150-Djb7F1bw.png",h="/blogs/assets/image-20230930210923271-DTuX3R9t.png",d="/blogs/assets/image-20230930210514171-Bm2gUlV4.png",u="/blogs/assets/image-20230514120255103-p6KhCdAA.png",_="/blogs/assets/image-20230514120315909-BL7MUx0z.png",b={};function f(x,e){return l(),s("div",null,e[0]||(e[0]=[i('<h2 id="定义mime-type" tabindex="-1"><a class="header-anchor" href="#定义mime-type"><span>定义MIME-Type</span></a></h2><ul><li>我们都知道浏览器中可以显示的内容有HTML、XML、GIF等种类繁多的 文件、媒体等资源，浏览器为了区分这些资源，就需要使用MIME Type。所以说MIME Type是网络资源的媒体类型。Nginx作为web服务 器，也需要能够识别前端请求的资源类型。</li></ul><p><img src="'+t+'" alt="image-20230928165711499"></p><h2 id="default-type" tabindex="-1"><a class="header-anchor" href="#default-type"><span>default_type</span></a></h2><ul><li>用来配置Nginx响应前端请求默认的MIME类型。</li></ul><p><img src="'+p+'" alt="image-20230514115450022"></p><ul><li>例子 <ul><li>以json字符串进行展示</li></ul></li></ul><p><img src="'+n+'" alt="image-20230928165917418"></p><h2 id="自定义服务日志" tabindex="-1"><a class="header-anchor" href="#自定义服务日志"><span>自定义服务日志</span></a></h2><ul><li><p>Nginx中日志的类型分access.log、error.log。</p><ul><li><p>access.log:用来记录用户所有的访问请求。</p></li><li><p>error.log:记录nginx本身运行时的错误信息，不会记录用户的访问请 求。</p></li></ul></li><li><p>Nginx服务器支持对服务日志的格式、大小、输出等进行设置，需要使 用到两个指令，分别是access_log和log_format指令。</p></li></ul><h2 id="access-log" tabindex="-1"><a class="header-anchor" href="#access-log"><span>access_log</span></a></h2><ul><li>用来设置用户访问日志的相关属性。</li></ul><p><img src="'+o+'" alt="image-20230514120131233"></p><h2 id="log-format" tabindex="-1"><a class="header-anchor" href="#log-format"><span>log_format</span></a></h2><ul><li>用来指定日志的输出格式。</li></ul><p><img src="'+r+'" alt="image-20230514120151837"></p><h2 id="默认的main日志格式" tabindex="-1"><a class="header-anchor" href="#默认的main日志格式"><span>默认的main日志格式</span></a></h2><p><img src="'+g+'" alt="image-20230927164932993"></p><ul><li>参数明细表</li></ul><p><img src="'+m+'" alt="image-20230927164948472"></p><h2 id="sendfile" tabindex="-1"><a class="header-anchor" href="#sendfile"><span>sendfile</span></a></h2><ul><li>用来设置Nginx服务器是否使用sendfile()传输文件，该属 性可以大大提高Nginx处理静态资源的性能</li></ul><p><img src="'+c+'" alt="image-20230514120233150"></p><ul><li>使用sendfile</li></ul><p><img src="'+h+'" alt="image-20230930210923271"></p><ul><li>不使用sendfile</li></ul><p><img src="'+d+'" alt="image-20230930210514171"></p><h2 id="keepalive-timeout" tabindex="-1"><a class="header-anchor" href="#keepalive-timeout"><span>keepalive_timeout</span></a></h2><ul><li>用来设置长连接的超时时间。</li></ul><p><img src="'+u+'" alt="image-20230514120255103"></p><ul><li>如何客户端向服务端发送多个请求，每个请求都需要重新创建一次连接， 效率相对来说比较多，使用keepalive模式，可以告诉服务器端在处理完 一个请求后保持这个TCP连接的打开状态，若接收到来自这个客户端的其 他请求，服务端就会利用这个未被关闭的连接，而不需要重新创建一个新 连接，提升效率，但是这个连接也不能一直保持，这样的话，连接如果过 多，也会是服务端的性能下降，这个时候就需要我们进行设置其的超时时 间。</li></ul><h2 id="keepalive-requests" tabindex="-1"><a class="header-anchor" href="#keepalive-requests"><span>keepalive_requests</span></a></h2><ul><li>用来设置一个keep-alive连接使用的次数。</li></ul><p><img src="'+_+'" alt="image-20230514120315909"></p>',34)]))}const M=a(b,[["render",f]]),k=JSON.parse('{"path":"/os/34ob6ubt/","title":"http块","lang":"zh-CN","frontmatter":{"title":"http块","createTime":"2025/04/05 16:36:31","permalink":"/os/34ob6ubt/"},"headers":[],"readingTime":{"minutes":1.88,"words":565},"git":{"updatedTime":1743864983000,"contributors":[{"name":"舒永好","username":"舒永好","email":"shuyonghao@guoshenghuaxing.com","commits":1,"avatar":"https://gravatar.com/avatar/4b1c3f37ea707968be73c631a79de33afd360724ce87bf8f9dcacd67d14df92c?d=retro"}]},"filePathRelative":"notes/os/nginx/base/http_block.md"}');export{M as comp,k as data};
