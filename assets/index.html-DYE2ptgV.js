import{_ as o,c as d,a as s,o as r}from"./app-C7T5jqfQ.js";const c={};function t(a,e){return r(),d("div",null,e[0]||(e[0]=[s('<h2 id="描述" tabindex="-1"><a class="header-anchor" href="#描述"><span>描述</span></a></h2><p>包含文件 <code>assert.hrl</code> 提供了在程序代码中插入断言的宏。</p><p>在调用该函数的模块中包含以下指令：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-include_lib(&quot;stdlib/include/assert.hrl&quot;).</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当断言成功时，assert 宏返回原子 <code>ok</code>。当断言失败时，会生成一种名为 <code>error</code> 的异常。关联的错误项具有形式 <code>{Macro, Info}</code>。<code>Macro</code> 是宏的名称，例如， <code>assertEqual</code>. <code>Info</code> 是一个带标签的值列表，例如 <code>[{模块, M}, {行, L}, ...]</code>，提供了异常位置和原因的更多信息。<code>Info</code> 列表中的所有条目都是可选的；不要在程序中依赖它们中的任何一个存在。</p><p>每个断言宏都有一个带有额外参数的版本，用于添加 评论到断言。这些评论可以例如作为错误报告的一部分打印，以澄清哪个检查失败了。例如， <code>?assertEqual(0, fib(0), &quot;Fibonacci is defined for zero&quot;)</code> . 评论文本可以是任何字符数据（字符串、UTF8-二进制或这样的数据的深层列表），并将作为<code>{评论, 文本}</code>包含在错误项中。 <code>?assertEqual(0, fib(0), &quot;Fibonacci is defined for zero&quot;)</code> .</p><p>如果在编译时定义了宏<code>NOASSERT</code>，当读取<code>assert.hrl</code>时，这些宏将被定义为等同于原子<code>ok</code>。测试将不会执行，运行时没有开销。</p><p>例如，使用<code>erlc</code>编译模块时，以下内容将禁用所有断言：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>erlc -DNOASSERT=true *.erl</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>（<code>NOASSERT</code>的值无关紧要，重要的是它被定义了。）</p><p>几个其他宏也会影响断言的启用或禁用：</p><ul><li>如果定义了<code>NODEBUG</code>，则意味着定义了<code>NOASSERT</code>（除非同时定义了<code>DEBUG</code>，这将覆盖<code>NODEBUG</code>）。</li><li>如果定义了<code>ASSERT</code>，则会覆盖<code>NOASSERT</code>，也就是说，断言仍然保持启用状态。</li></ul><p>如果您愿意，可以仅使用 <code>DEBUG</code>/<code>NODEBUG</code> 作为主要标志来控制断言的行为（如果其他编译条件或调试宏由这些标志控制的话，这很有用），或者可以使用 <code>ASSERT</code>/<code>NOASSERT</code> 仅控制断言宏。</p><h2 id="宏" tabindex="-1"><a class="header-anchor" href="#宏"><span>宏</span></a></h2><ul><li><p><strong><code>assert(BoolExpr)</code></strong></p></li><li><p><strong><code>assert(BoolExpr, Comment)</code></strong> - 测试 <code>BoolExpr</code> 是否正常完成并返回 <code>true</code>。</p></li><li><p><strong><code>assertNot(BoolExpr)</code></strong></p></li><li><p><strong><code>assertNot(BoolExpr, Comment)</code></strong> - 测试 <code>BoolExpr</code> 是否正常完成并返回 <code>false</code>。</p></li><li><p><strong><code>assertMatch(GuardedPattern, Expr)</code></strong></p></li><li><p><strong><code>assertMatch(GuardedPattern, Expr, Comment)</code></strong> - 测试 <code>Expr</code> 是否正常完成并返回一个与 <code>GuardedPattern</code> 匹配的值，例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>?assertMatch({bork, _}, f())</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>注意可以包含一个守卫 <code>when ...</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>?assertMatch({bork, X} when X &gt; 0, f())</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong><code>assertNotMatch(GuardedPattern, Expr)</code></strong></p></li><li><p><strong><code>assertNotMatch(GuardedPattern, Expr, Comment)</code></strong> - 测试 <code>Expr</code> 能正常完成并返回一个不匹配 <code>GuardedPattern</code> 的值。 与 <strong>assertMatch 类似，<code>GuardedPattern</code> 可以包含一个 <code>when</code> 部分。</strong></p><p>与 <code>assertMatch</code> 类似，<code>GuardedPattern</code> 可以包含一个 <code>when</code> 部分。</p></li><li><p><strong><code>assertEqual(ExpectedValue, Expr)</code></strong></p></li><li><p><strong><code>assertEqual(ExpectedValue, Expr, Comment)</code></strong> - 测试表达式 <code>Expr</code> 能够正常完成并返回一个与 <code>ExpectedValue</code> 完全相等的值。</p></li><li><p><strong><code>assertNotEqual(ExpectedValue, Expr)</code></strong></p></li><li><p><strong><code>assertNotEqual(ExpectedValue, Expr, Comment)</code></strong> - 测试表达式 <code>Expr</code> 能够正常完成并返回一个与 <code>ExpectedValue</code>.</p></li><li><p><strong><code>assertException(Class, Term, Expr)</code></strong></p></li><li><p><strong><code>assertException(Class, Term, Expr, Comment)</code></strong> - 测试 <code>Expr</code> 异常退出。 完成时抛出类型为 <code>Class</code> 的异常，并附带 断言失败如果<code>Term</code>抛出不同的异常，或者正常完成并返回任何值。</p><p>请注意，无论是<code>Class</code>还是<code>Term</code>都可以是受保护的模式，例如 <code>assertMatch</code>。</p></li><li><p><strong><code>assertNotException(Class, Term, Expr)</code></strong></p></li><li><p>测试 <code>Expr</code> 不以类型为 <code>Class</code> 的异常 <code>Term</code> 的方式异常终止。如果 <code>Expr</code> 抛出其他异常或正常完成并返回任何值，则断言成功。</p><p>类似于 <code>assertException</code>，<code>Class</code> 和 <code>Term</code> 都可以是受保护的模式。</p></li><li><p><strong><code>assertError(Term, Expr)</code></strong></p></li><li><p><strong><code>assertError(Term, Expr, Comment)</code></strong> - 等价于 <code>assertException(error, Term, Expr)</code></p></li><li><p><strong><code>assertExit(Term, Expr)</code></strong></p></li><li><p><strong><code>assertExit(Term, Expr, Comment)</code></strong> - 相当于 <code>assertException(exit, Term, Expr)</code></p></li><li><p><strong><code>assertThrow(Term, Expr)</code></strong></p></li><li><p><strong><code>assertThrow(Term, Expr, Comment)</code></strong> - 相当于 <code>assertException(throw, Term, Expr)</code></p></li></ul>',15)]))}const n=o(c,[["render",t]]),l=JSON.parse('{"path":"/backend/erlang/xnywoxqo/","title":"assert.hrl","lang":"zh-CN","frontmatter":{"title":"assert.hrl","createTime":"2025/03/23 14:40:59","permalink":"/backend/erlang/xnywoxqo/"},"headers":[],"readingTime":{"minutes":3.01,"words":904},"git":{"updatedTime":1743091220000,"contributors":[{"name":"舒永好","username":"舒永好","email":"shuyonghao@guoshenghuaxing.com","commits":1,"avatar":"https://gravatar.com/avatar/4b1c3f37ea707968be73c631a79de33afd360724ce87bf8f9dcacd67d14df92c?d=retro"}]},"filePathRelative":"notes/backend/erlang/erlang_core/stdlib/assert.md"}');export{n as comp,l as data};
