import{_ as s,c as a,a as n,o as r}from"./app-C7T5jqfQ.js";const i={};function t(o,e){return r(),a("div",null,e[0]||(e[0]=[n(`<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h2><p>截至撰写本文时，即 2020 年 10 月，有关通用资源标识符和通用资源定位器有两个主要标准：</p><ul><li><a href="https://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener noreferrer">RFC 3986 - 统一资源标识符（URI）：通用语法</a></li><li><a href="https://url.spec.whatwg.org/" target="_blank" rel="noopener noreferrer">WHAT WG URL - 生活标准</a></li></ul><p>前者是一种具有正式形式语法的经典标准，使用所谓的扩展巴科斯-诺尔范式（ABNF）来描述语法，而后者则是一种描述当前实践的活文档，即大多数 Web 浏览器如何处理 URI。WHAT WG 前者是一种具有正式形式语法的经典标准，使用所谓的扩展巴科斯-诺尔范式（ABNF）来描述语法，而后者则是一种描述当前实践的活文档，即大多数 Web 浏览器如何处理 URI。WHAT WG 前者是一种具有正式形式语法的经典标准，使用所谓的扩展巴科斯-诺尔范式（ABNF）来描述语法，而后者则是一种描述当前实践的活文档，即大多数 Web 浏览器如何处理 URI。WHAT WG URL 是以 Web 为中心的，并且没有正式的语法，而是一个简单的英语描述 应该遵循的算法。</p><p>他们之间有什么区别，如果有的话？它们提供了重叠的 定义了资源标识符，它们不兼容。The <a href="https://www.erlang.org/doc/apps/stdlib/uri_string" target="_blank" rel="noopener noreferrer"><code>uri_string</code></a> 模块实现了 <a href="https://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener noreferrer">RFC 3986</a>，并且在整个文档中将使用术语 URI。URI 是一个标识符，是一串字符，用于标识特定的资源。 它是一个标识符，是一串字符，用于标识特定的资源。</p><p>有关 URIs 的完整问题描述，请参阅 <a href="https://tools.ietf.org/html/draft-ruby-url-problem-01" target="_blank" rel="noopener noreferrer">URL 问题陈述和指南</a>。</p><h2 id="什么是-uri" tabindex="-1"><a class="header-anchor" href="#什么是-uri"><span>什么是 URI？</span></a></h2><p>让我们先说它不是什么。它不是你在网络浏览器地址栏中输入的文本。网络浏览器会尽可能地将输入转换为一个有效的 URI，以便通过网络发送。</p><p>URI 是一个由字符序列组成的标识符，这些字符序列符合 <code>URI</code> 在 <a href="https://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener noreferrer">RFC 3986</a> 中定义的语法规则。</p><p>重要的是要澄清，一个 <em>字符</em> 是在终端上显示或打印到纸上的符号，不应与它的内部表示混淆。</p><p>具体来说，URI 是一个来自 US ASCII 字符集的字符序列。 通用的 URI 语法结构是一个分层的序列，称为方案、权威、路径、查询和片段。 具体来说，URI 是一个分层的序列，称为方案、权威、路径、查询和片段。 每个这些组件都有正式的描述在 <a href="https://www.ietf.org/rfc/rfc2234.txt" target="_blank" rel="noopener noreferrer">ABNF</a> 标记中在 <a href="https://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener noreferrer">RFC 3986</a> 中：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    URI         = scheme &quot;:&quot; hier-part [ &quot;?&quot; query ] [ &quot;#&quot; fragment ]</span></span>
<span class="line"><span>    hier-part   = &quot;//&quot; authority path-abempty</span></span>
<span class="line"><span>                   / path-absolute</span></span>
<span class="line"><span>                   / path-rootless</span></span>
<span class="line"><span>                   / path-empty</span></span>
<span class="line"><span>    scheme      = ALPHA *( ALPHA / DIGIT / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; )</span></span>
<span class="line"><span>    authority   = [ userinfo &quot;@&quot; ] host [ &quot;:&quot; port ]</span></span>
<span class="line"><span>    userinfo    = *( unreserved / pct-encoded / sub-delims / &quot;:&quot; )</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    reserved    = gen-delims / sub-delims</span></span>
<span class="line"><span>    gen-delims  = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; / &quot;#&quot; / &quot;[&quot; / &quot;]&quot; / &quot;@&quot;</span></span>
<span class="line"><span>    sub-delims  = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#39;&quot; / &quot;(&quot; / &quot;)&quot;</span></span>
<span class="line"><span>                / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    unreserved  = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="uri-string-模块" tabindex="-1"><a class="header-anchor" href="#uri-string-模块"><span>uri_string 模块</span></a></h2><p>由于生成和消费标准 URI 可能会变得相当复杂，Erlang/OTP 提供了一个模块 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string" target="_blank" rel="noopener noreferrer"><code>uri_string</code></a>，用于处理诸如解析、重组、规范化和相对于基 URI 解析 URI 等所有最复杂的操作。</p><p><a href="https://www.erlang.org/doc/apps/stdlib/uri_string" target="_blank" rel="noopener noreferrer"><code>uri_string</code></a> 模块中的 API 函数基于两种基本数据类型工作 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_string/0" target="_blank" rel="noopener noreferrer"><code>uri_string()</code></a> 和 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_map/0" target="_blank" rel="noopener noreferrer"><code>uri_map()</code></a>。 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_string/0" target="_blank" rel="noopener noreferrer"><code>uri_string()</code></a> 表示一个标准的 URI，而 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_map/0" target="_blank" rel="noopener noreferrer"><code>uri_map()</code></a> 是一个更广泛的类型，可以使用<a href="https://www.erlang.org/doc/apps/stdlib/unicode_usage#what-unicode-is" target="_blank" rel="noopener noreferrer">Unicode</a>字符来表示 URI 组件。 <code>[</code>uri_map()<code>](https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_map/0)</code> 是一个方便的选择，可以用于从包含特殊字符或 Unicode 字符的组件中生成符合标准的 URI。通过一个例子来解释这一点会更容易。</p><p>假设我们想要创建以下 URI 并将其发送到网络中：<code>http://cities/örebro?foo bar</code>。这不是一个有效的 URI，因为它包含 URI 中不允许的字符，如“ö”和空格。我们可以通过解析 URI 来验证这一点：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>  1&gt; uri_string:parse(&quot;http://cities/örebro?foo bar&quot;).</span></span>
<span class="line"><span>  {error,invalid_uri,&quot;:&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>URI 解析器会尝试所有可能的组合来解释输入，并在遇到冒号字符<code>&quot;:&quot;</code>时在最后一次尝试中失败。请注意，初始错误发生在解析器尝试解释字符<code>&quot;ö&quot;</code>时。 并且在失败后，解析器会回溯到另一个可能的解析点。 之后。</p><p>解决这个问题的正确方法是使用 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#recompose/1" target="_blank" rel="noopener noreferrer"><code>uri_string:recompose/1</code></a> 作为输入： <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_map/0" target="_blank" rel="noopener noreferrer"><code>uri_map()</code></a> 作为输入：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>  2&gt; uri_string:recompose(#{scheme =&gt; &quot;http&quot;, host =&gt; &quot;cities&quot;, path =&gt; &quot;/örebro&quot;,</span></span>
<span class="line"><span>  query =&gt; &quot;foo bar&quot;}).</span></span>
<span class="line"><span>  &quot;http://cities/%C3%B6rebro?foo%20bar&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果是一个有效的 URI，其中所有特殊字符都按照标准进行了编码。应用<a href="https://www.erlang.org/doc/apps/stdlib/uri_string#parse/1" target="_blank" rel="noopener noreferrer"><code>uri_string:parse/1</code></a>和 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#percent_decode/1" target="_blank" rel="noopener noreferrer"><code>uri_string:percent_decode/1</code></a>对 URI 进行处理后会返回原始输入：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>  3&gt; uri_string:percent_decode(uri_string:parse(&quot;http://cities/%C3%B6rebro?foo%20bar&quot;)).</span></span>
<span class="line"><span>  #{host =&gt; &quot;cities&quot;,path =&gt; &quot;/örebro&quot;,query =&gt; &quot;foo bar&quot;,</span></span>
<span class="line"><span>  scheme =&gt; &quot;http&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个对称性质在我们的属性测试套件中被大量使用。</p><h2 id="百分比编码" tabindex="-1"><a class="header-anchor" href="#百分比编码"><span>百分比编码</span></a></h2><p>如您在上一章中所见，标准 URI 只能包含 US ASCII 字符集的一个严格子集，而且在不同的 URI 组件中允许的字符集是不同的。百分比编码是一种机制，用于在组件中表示数据字节，当该字节对应字符不在允许的字符集内或被用作分隔符时。这就是为什么<code>&quot;ö&quot;</code>会被编码为<code>%C3%B6</code>，而<code>空格</code>则被编码为<code>%20</code>。大多数 API 函数在处理 百分比编码的三元组时，期望使用 UTF-8 编码。 UTF-8 编码的 Unicode 字符<code>&quot;ö&quot;</code>是两个字节： <code>0xC3 0xB6</code>。字符<code>空格</code>在 Unicode 的前 128 个字符中 并且它使用一个字节进行编码<code>0x20</code>。</p><h3 id="注意" tabindex="-1"><a class="header-anchor" href="#注意"><span>注意</span></a></h3><p>Unicode 与 ASCII 兼容，前 128 个字符的编码二进制值与 ASCII 相同。</p><p>确切地说，哪些 字符会被百分比编码是一个主要的混淆源。为了更容易回答这个问题， 库提供了一个实用函数， <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#allowed_characters/0" target="_blank" rel="noopener noreferrer"><code>uri_string:allowed_characters/0</code></a>，它列出了每个主要 URI 组件允许的字符集，以及最重要的标准字符集。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    1&gt; uri_string:allowed_characters().</span></span>
<span class="line"><span>    [{scheme,</span></span>
<span class="line"><span>     &quot;+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;},</span></span>
<span class="line"><span>    {userinfo,</span></span>
<span class="line"><span>     &quot;!$%&amp;&#39;()*+,-.0123456789:;=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~&quot;},</span></span>
<span class="line"><span>    {host,</span></span>
<span class="line"><span>     &quot;!$&amp;&#39;()*+,-.0123456789:;=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~&quot;},</span></span>
<span class="line"><span>    {ipv4,&quot;.0123456789&quot;},</span></span>
<span class="line"><span>    {ipv6,&quot;.0123456789:ABCDEFabcdef&quot;},</span></span>
<span class="line"><span>    {regname,</span></span>
<span class="line"><span>     &quot;!$%&amp;&#39;()*+,-.0123456789;=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~&quot;},</span></span>
<span class="line"><span>    {path,</span></span>
<span class="line"><span>     &quot;!$%&amp;&#39;()*+,-./0123456789:;=@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~&quot;},</span></span>
<span class="line"><span>    {query,</span></span>
<span class="line"><span>     &quot;!$%&amp;&#39;()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~&quot;},</span></span>
<span class="line"><span>    {fragment,</span></span>
<span class="line"><span>     &quot;!$%&amp;&#39;()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~&quot;},</span></span>
<span class="line"><span>    {reserved,&quot;!#$&amp;&#39;()*+,/:;=?@[]&quot;},</span></span>
<span class="line"><span>    {unreserved,</span></span>
<span class="line"><span>     &quot;-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~&quot;}]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 URI 组件包含不允许的字符，当生成 URI 时，这些字符将会被百分号编码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    2&gt; uri_string:recompose(#{scheme =&gt; &quot;https&quot;, host =&gt; &quot;local#host&quot;, path =&gt; &quot;&quot;}).</span></span>
<span class="line"><span>    &quot;https://local%23host&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>消费包含百分比编码三元组的 URI 可能需要多步。例如， 以下示例展示了如何处理一个未规范化且包含多个百分比编码三元组的输入 URI。首先，输入 contains multiple percent-encoded triplets. First, the input <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_string/0" target="_blank" rel="noopener noreferrer"><code>uri_string()</code></a> 将被解析成 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_map/0" target="_blank" rel="noopener noreferrer"><code>uri_map()</code></a>。解析只会将 URI 拆分成其各个部分，而不进行任何解码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    3&gt; uri_string:parse(&quot;http://%6C%6Fcal%23host/%F6re%26bro%20&quot;).</span></span>
<span class="line"><span>    #{host =&gt; &quot;%6C%6Fcal%23host&quot;,path =&gt; &quot;/%F6re%26bro%20&quot;,</span></span>
<span class="line"><span>      scheme =&gt; &quot;http&quot;}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输入是一个有效的 URI，但你如何解码那些百分号编码的八位字节？你可以尝试使用<a href="https://www.erlang.org/doc/apps/stdlib/uri_string#normalize/1" target="_blank" rel="noopener noreferrer"><code>uri_string:normalize/1</code></a>对输入进行规范化。规范化操作会解码那些对应于未保留集字符的百分号编码三元组。规范化是一个安全的、幂等的操作，它将 URI 转换为其规范形式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    4&gt; uri_string:normalize(&quot;http://%6C%6Fcal%23host/%F6re%26bro%20&quot;).</span></span>
<span class="line"><span>    &quot;http://local%23host/%F6re%26bro%20&quot;</span></span>
<span class="line"><span>    5&gt; uri_string:normalize(&quot;http://%6C%6Fcal%23host/%F6re%26bro%20&quot;, [return_map]).</span></span>
<span class="line"><span>    #{host =&gt; &quot;local%23host&quot;,path =&gt; &quot;/%F6re%26bro%20&quot;,</span></span>
<span class="line"><span>      scheme =&gt; &quot;http&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出中还有一些百分比编码的三元组。在这个 点，当 URI 已经被解析时，可以在剩余的字符三元组上安全地应用特定应用的解码。Erlang/OTP 提供了一个函数， 用于对剩余字符三元组进行特定应用的解码。Erlang/OTP 提供了一个函数， <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#percent_decode/1" target="_blank" rel="noopener noreferrer"><code>uri_string:percent_decode/1</code></a> 用于原始的百分比解码，你可以在主机和路径组件上使用它，或者在整个映射上使用：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    6&gt; uri_string:percent_decode(&quot;local%23host&quot;).</span></span>
<span class="line"><span>    &quot;local#host&quot;</span></span>
<span class="line"><span>    7&gt; uri_string:percent_decode(&quot;/%F6re%26bro%20&quot;).</span></span>
<span class="line"><span>    {error,invalid_utf8,&lt;&lt;&quot;/öre&amp;bro &quot;&gt;&gt;}</span></span>
<span class="line"><span>    8&gt; uri_string:percent_decode(#{host =&gt; &quot;local%23host&quot;,path =&gt; &quot;/%F6re%26bro%20&quot;,</span></span>
<span class="line"><span>    scheme =&gt; &quot;http&quot;}).</span></span>
<span class="line"><span>    {error,{invalid,{path,{invalid_utf8,&lt;&lt;&quot;/öre&amp;bro &quot;&gt;&gt;}}}}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主机 <code>host</code> 成功解码，但路径包含至少一个非 UTF-8 编码的字符。为了能够解码这些字符，你需要对这些三元组中使用的编码做出假设。最明显的选择是 <em>latin-1</em>，因此你可以尝试 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#transcode/2" target="_blank" rel="noopener noreferrer"><code>uri_string:transcode/2</code></a>，将路径转换为 UTF-8，并在转换后的字符串上运行百分比解码操作：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    9&gt; uri_string:transcode(&quot;/%F6re%26bro%20&quot;, [{in_encoding, latin1}]).</span></span>
<span class="line"><span>    &quot;/%C3%B6re%26bro%20&quot;</span></span>
<span class="line"><span>    10&gt; uri_string:percent_decode(&quot;/%C3%B6re%26bro%20&quot;).</span></span>
<span class="line"><span>    &quot;/öre&amp;bro &quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>必须强调，直接对输入的 URI 应用 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#percent_decode/1" target="_blank" rel="noopener noreferrer"><code>uri_string:percent_decode/1</code></a> 是不安全的：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    11&gt; uri_string:percent_decode(&quot;http://%6C%6Fcal%23host/%C3%B6re%26bro%20&quot;).</span></span>
<span class="line"><span>    &quot;http://local#host/öre&amp;bro &quot;</span></span>
<span class="line"><span>    12&gt; uri_string:parse(&quot;http://local#host/öre&amp;bro &quot;).</span></span>
<span class="line"><span>    {error,invalid_uri,&quot;:&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="注意-1" tabindex="-1"><a class="header-anchor" href="#注意-1"><span>注意</span></a></h3><p>百分比编码在<a href="https://www.erlang.org/doc/apps/stdlib/uri_string#recompose/1" target="_blank" rel="noopener noreferrer"><code>uri_string:recompose/1</code></a>中实现，并在将<a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_map/0" target="_blank" rel="noopener noreferrer"><code>uri_map()</code></a>转换为 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_string/0" target="_blank" rel="noopener noreferrer"><code>uri_string()</code></a>时发生。直接对输入 URI 进行百分比编码 与直接对输入 URI 进行任何百分比编码一样不安全。 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#percent_decode/1" target="_blank" rel="noopener noreferrer"><code>uri_string:percent_decode/1</code></a>，输出可能是无效的 URI。编码和解码 函数允许用户对不能自动处理的应用数据进行原始的百分比编码和解码 函数不能自动处理的应用数据进行原始的百分比编码和解码 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#recompose/1" target="_blank" rel="noopener noreferrer"><code>uri_string:recompose/1</code></a>. 例如，在用户需要在路径组件中使用 &#39;/&#39; 或子分隔符作为数据而不是分隔符的情况下。</p><h2 id="标准化" tabindex="-1"><a class="header-anchor" href="#标准化"><span>标准化</span></a></h2><p>正常化是将输入的 URI 转换为<em>规范</em>形式并保持对同一资源的引用的操作。最常见的一种应用是确定两个 URI 是否等价 正常化是将输入的 URI 转换为<em>规范</em>形式并保持对同一资源的引用的操作。最常见的一种应用是确定两个 URI 是否等价 正常化是将输入的 URI 转换为<em>规范</em>形式并保持对同一资源的引用的操作。最常见的一种应用是确定两个 URI 是否等价 不访问其引用的资源。</p><p>正规化有 6 个不同的步骤。首先，输入的 URI 会被解析成一种中间形式，可以处理<a href="https://www.erlang.org/doc/apps/stdlib/unicode_usage#what-unicode-is" target="_blank" rel="noopener noreferrer">Unicode</a>字符。 这种数据类型是<a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_map/0" target="_blank" rel="noopener noreferrer"><code>uri_map()</code></a>，它可以存储 URI 的各个组件。 在映射元素类型中。 <a href="https://www.erlang.org/doc/apps/stdlib/unicode#t:chardata/0" target="_blank" rel="noopener noreferrer"><code>unicode:chardata/0</code></a>. 在有了中间形式之后，会对每个 URI 组件应用一系列的规范化算法：</p><ul><li><strong>大小写规范化</strong> - 将 <code>scheme</code> 和 <code>host</code> 组件转换为小写，因为它们不区分大小写。</li><li><strong>百分比编码规范化</strong> - 解码对应于未保留集中字符的百分比编码三元组。</li><li><strong>基于方案的规范化</strong> - 应用 http、https、ftp、ssh、sftp 和 tftp 的规则。</li><li><strong>路径段规范化</strong> - 将路径转换为规范形式。</li></ul><p>经过这些步骤，中间数据结构，一个 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#t:uri_map/0" target="_blank" rel="noopener noreferrer"><code>uri_map()</code></a> 已完全规范化。最后一步是应用 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#recompose/1" target="_blank" rel="noopener noreferrer"><code>uri_string:recompose/1</code></a>，将其中间结构转换为有效的规范 URI 字符串。</p><p>注意顺序，我们多次在用户指南中使用的 <a href="https://www.erlang.org/doc/apps/stdlib/uri_string#normalize/2" target="_blank" rel="noopener noreferrer"><code>uri_string:normalize(URIMap, [return_map\\])</code></a>是在规范化过程中的一个快捷方式，返回中间数据结构，并允许我们检查并进一步解码剩余的百分比编码三元组。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>    13&gt; uri_string:normalize(&quot;hTTp://LocalHost:80/%c3%B6rebro/a/../b&quot;).</span></span>
<span class="line"><span>    &quot;http://localhost/%C3%B6rebro/b&quot;</span></span>
<span class="line"><span>    14&gt; uri_string:normalize(&quot;hTTp://LocalHost:80/%c3%B6rebro/a/../b&quot;, [return_map]).</span></span>
<span class="line"><span>    #{host =&gt; &quot;localhost&quot;,path =&gt; &quot;/%C3%B6rebro/b&quot;,</span></span>
<span class="line"><span>      scheme =&gt; &quot;http&quot;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="特殊考虑事项" tabindex="-1"><a class="header-anchor" href="#特殊考虑事项"><span>特殊考虑事项</span></a></h2><p>当前的 URI 实现提供了生成和消费标准 URI 的支持。API 并不打算直接暴露在 Web 浏览器的地址栏中，用户可以在其中基本输入自由文本。应用程序设计者应当实现适当的启发式方法，将输入映射为可解析的 URI。</p>`,52)]))}const p=s(i,[["render",t]]),d=JSON.parse('{"path":"/backend/erlang/juz76an6/","title":"统一资源标识符","lang":"zh-CN","frontmatter":{"title":"统一资源标识符","createTime":"2025/03/23 14:40:20","permalink":"/backend/erlang/juz76an6/"},"headers":[],"readingTime":{"minutes":10.17,"words":3051},"git":{"updatedTime":1743091220000,"contributors":[{"name":"舒永好","username":"舒永好","email":"shuyonghao@guoshenghuaxing.com","commits":1,"avatar":"https://gravatar.com/avatar/4b1c3f37ea707968be73c631a79de33afd360724ce87bf8f9dcacd67d14df92c?d=retro"}]},"filePathRelative":"notes/backend/erlang/erlang_core/stdlib/url.md"}');export{p as comp,d as data};
