import{_ as e,c as o,a as n,o as t}from"./app-C7T5jqfQ.js";const i="/blogs/assets/image-20250328105628494-glvptDJ2.png",s={};function r(p,a){return t(),o("div",null,a[0]||(a[0]=[n('<div class="hint-container tip"><p class="hint-container-title">提示</p><p>Cowboy 是一个轻量级的 HTTP 服务器，支持 HTTP/1.1、HTTP/2 和 Websocket。</p><p>它基于 Ranch 构建</p></div><h2 id="概览" tabindex="-1"><a class="header-anchor" href="#概览"><span>概览</span></a></h2><p><img src="'+i+'" alt="image-20250328105628494"></p><p>如图所示，客户端首先连接到服务器。这一步由一个 Ranch 接受器处理，它是专门用于接受新连接的过程。</p><ul><li>在 Ranch 接受一个新连接之后，无论是 HTTP/1.1 还是 HTTP/2 连接，Cowboy 都会开始接收请求并处理它们。 <ul><li>在 HTTP/1.1 中，所有请求都是按顺序进行的。</li><li>在 HTTP/2 中，请求可以同时到达并被处理。</li></ul></li></ul><p>当请求到达时，Cowboy 会创建一个流，这是一个请求/响应集以及与它们相关的所有事件。</p><ul><li>Cowboy 中的协议代码将处理这些流的任务委托给流处理器模块。</li><li>当你配置 Cowboy 时，你可以定义一个或多个模块来接收与流相关的所有事件，包括请求、响应、主体、Erlang 消息等。</li><li>默认情况下，Cowboy 配置了一个名为 <code>cowboy_stream_h</code> 的流处理器。这个流处理器会为每个请求创建一个新的进程，然后与这个进程通信以读取主体或发送响应。请求进程执行中间件。 <ul><li>默认情况下，请求进程执行路由器，然后执行处理器。就像流处理器一样，中间件也可以进行自定义。</li></ul></li></ul><p>在这个图中的几乎任何点都可以发送响应。如果响应必须在流初始化之前发送（例如，因为早期发生错误），那么流处理器将接收到一个特殊事件来指示这个错误。</p><h2 id="协议特定的头部" tabindex="-1"><a class="header-anchor" href="#协议特定的头部"><span>协议特定的头部</span></a></h2><p>Cowboy 处理协议特定的头部，防止你手动发送它们。</p><ul><li>对于 HTTP/1.1，这包括 <code>transfer-encoding</code> 和 <code>connection</code> 头部。</li><li>对于 HTTP/2，这包括像 <code>:status</code> 这样的冒号头部。</li></ul><p>Cowboy 还会在将请求传递给流处理器之前移除协议特定的头部。Cowboy 尽可能隐藏所有协议的实现细节。</p><h2 id="每个连接中的进程数量" tabindex="-1"><a class="header-anchor" href="#每个连接中的进程数量"><span>每个连接中的进程数量</span></a></h2><p>默认情况下，Cowboy 会为每个连接使用一个进程，并为每个请求/响应集（称为流，在内部）使用一个进程。</p><p>它为每个请求创建一个新进程，这是由于 HTTP/2 的要求，其中请求可以并发且独立于连接执行。来自不同请求的帧最终会在单个 TCP 连接上交错。</p><p>请求进程从不重用。因此，在响应发送后无需执行任何清理操作。进程将终止，Erlang/OTP 将一次性回收所有内存。</p><p>Cowboy 最终并不需要每个连接超过一个进程。可以从流处理器直接与连接交互，这是一个低级接口，用于与 Cowboy 交互。它们在连接进程中执行，并可以处理传入的请求并发送响应。然而，在正常情况下，这并不推荐，因为流处理器执行时间过长可能会对并发请求或连接本身的状态产生负面影响。</p><h2 id="日期头" tabindex="-1"><a class="header-anchor" href="#日期头"><span>日期头</span></a></h2><p>由于查询当前日期和时间可能会很昂贵，Cowboy 每秒生成一个 <em>日期</em> 头值，并将其共享给所有其他进程，然后这些进程只需将其复制到响应中。这使得 Cowboy 能够遵守 HTTP/1.1 协议，同时没有任何实际的性能损失。</p><h2 id="二进制文件" tabindex="-1"><a class="header-anchor" href="#二进制文件"><span>二进制文件</span></a></h2><p>Cowboy 广泛使用二进制文件。</p><p>二进制比列表更有效地表示字符串，因为它们占用更少的内存空间。处理性能取决于操作。如果代码是本地编译的，二进制通常会获得很大的性能提升。请参阅 HiPE 文档以获取更多详细信息。</p><p>二进制数据可能会在进程之间共享。当一个进程无限期地保留二进制数据而不释放时，这可能导致一些巨大的内存使用。如果你的应用程序中看到一些奇怪的内存使用情况，这可能是原因。</p>',23)]))}const l=e(s,[["render",r]]),d=JSON.parse('{"path":"/backend/erlang/41hmbs1f/","title":"流程图","lang":"zh-CN","frontmatter":{"title":"流程图","createTime":"2025/03/28 10:54:36","permalink":"/backend/erlang/41hmbs1f/"},"headers":[],"readingTime":{"minutes":3.45,"words":1036},"git":{"updatedTime":1743158971000,"contributors":[{"name":"syh","username":"syh","email":"syh@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/060d67e779a1b0aeace68a2a010b367f852e56888393383ea27302df983f6814?d=retro"}]},"filePathRelative":"notes/backend/erlang/rebar3/cowboy/introduction/chart.md"}');export{l as comp,d as data};
