import{_ as e,c as n,a,o as i}from"./app-C7T5jqfQ.js";const l={};function d(p,s){return i(),n("div",null,s[0]||(s[0]=[a(`<p>Erlang 中的 I/O 协议使客户端和服务器之间能够进行双向通信。</p><ul><li>I/O 服务器是一个进程，负责处理请求并在例如 I/O 设备上执行请求的任务。</li><li>客户端是任何希望从 I/O 设备读取或写入数据的 Erlang 进程。</li></ul><p>常用的 I/O 协议自 OTP 诞生之初就存在，但一直未被文档化，并且也随着时间的推移而演变。在 Robert Virding 的论据的附录中，描述了原始的 I/O 协议。本节描述当前的 I/O 协议。</p><p>原始的 I/O 协议很简单且灵活。为了提高内存效率和执行时间效率，多年来对协议进行了扩展，使得协议变得更大，实现起来也比原来的要复杂一些。当然可以认为当前的协议过于复杂，但本节描述的是当前的协议，而不是它应该是什么样的。</p><p>原始协议的基本理念仍然适用。I/O 服务器和客户端使用一个相对简单的协议进行通信，客户端中从不包含服务器状态。任何 I/O 服务器都可以与任何客户端代码一起使用，而客户端代码无需了解 I/O 服务器通信的 I/O 设备。</p><h2 id="协议基础" tabindex="-1"><a class="header-anchor" href="#协议基础"><span>协议基础</span></a></h2><p>如罗伯特的论文所述，I/O 服务器和客户端是通过<code>io_request</code>/<code>io_reply</code>元组进行通信的。 <code>io_request</code>/<code>io_reply</code>元组如下所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{io_request, From, ReplyAs, Request}</span></span>
<span class="line"><span>{io_reply, ReplyAs, Reply}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端向 I/O 服务器发送一个<code>io_request</code>元组，服务器最终会发送一个相应的<code>io_reply</code>元组。</p><ul><li><p>&quot;From&quot; 是客户端的 <a href="https://www.erlang.org/doc/apps/erts/erlang#t:pid/0" target="_blank" rel="noopener noreferrer"><code>pid/0</code></a>，I/O 服务器将 I/O 回复发送到该进程。</p></li><li><p><code>ReplyAs</code> 可以是任何数据，并且会在相应的 <code>io_reply</code> 中返回。<a href="https://www.erlang.org/doc/apps/stdlib/io" target="_blank" rel="noopener noreferrer"><code>io</code></a> 模块监控 I/O 服务器，并使用监视引用作为 <code>ReplyAs</code> 数据。更复杂的客户端可以对同一个 I/O 服务器有多个待处理的 I/O 请求，并可以使用不同的引用（或其他内容）来区分传入的 I/O 回复。I/O 服务器应将元素 <code>ReplyAs</code> 视为不透明的。</p><p>注意，I/O 服务器的 <a href="https://www.erlang.org/doc/apps/erts/erlang#t:pid/0" target="_blank" rel="noopener noreferrer"><code>pid/0</code></a> 并未显式出现在元组中。 <code>io_reply</code>. 回复可以从任何进程发送，而不一定非得是实际的 I/O 服务器。</p></li><li><p><code>Request</code> 和 <code>Reply</code> 的描述如下。</p></li></ul><p>当 I/O 服务器接收到一个<code>io_request</code>元组时，它会处理<code>Request</code>部分，并最终发送一个带有相应<code>Reply</code>部分的<code>io_reply</code>元组。 当 I/O 服务器接收到一个<code>io_request</code>元组时，它会处理<code>Request</code>部分，并最终发送一个带有相应<code>Reply</code>部分的<code>io_reply</code>元组。 当 I/O 服务器接收到一个<code>io_request</code>元组时，它会处理<code>Request</code>部分，并最终发送一个带有相应<code>Reply</code>部分的<code>io_reply</code>元组。</p><h2 id="输出请求" tabindex="-1"><a class="header-anchor" href="#输出请求"><span>输出请求</span></a></h2><p>要在一个 I/O 设备上输出字符，存在以下 <code>Request</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{put_chars, Encoding, Characters}</span></span>
<span class="line"><span>{put_chars, Encoding, Module, Function, Args}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>编码</code>是<code>unicode</code>或<code>latin1</code>，这意味着字符（如果是二进制数据）以 UTF-8 或 ISO Latin-1（纯字节）编码。当<code>编码</code>设置为<code>latin1</code>时，一个表现良好的 I/O 服务器也应该在列表元素包含大于 255 的整数时返回错误指示。</p><p>请注意，这并不说明如何将字符输出到 I/O 设备或由 I/O 服务器处理。不同的 I/O 服务器可以按照它们自己的方式处理字符，这里只说明 I/O 服务器期望数据具有哪种格式。在<code>Module</code>/<code>Function</code>/<code>Args</code>的情况下，<code>Encoding</code>告诉指定函数产生哪种格式的数据。 说明了指定函数产生的数据格式。</p><p>注意，字节数据最简单的方式是使用 ISO Latin-1 编码发送。</p></li><li><p><code>字符</code>是要写入 I/O 设备的数据。如果<code>Encoding</code>是<code>latin1</code>，那么这是<a href="https://www.erlang.org/doc/apps/erts/erlang#t:iolist/0" target="_blank" rel="noopener noreferrer"><code>iolist/0</code></a>。如果<code>Encoding</code>是<code>unicode</code>，那么这是 Erlang 标准的混合 Unicode 列表（列表中的每个字符都是一个整数，二进制中的字符表示为 UTF-8）。 注意，字节数据最简单的方式是使用 ISO Latin-1 编码发送。</p></li><li><p><code>Module</code>, <code>Function</code> 和 <code>Args</code> 表示一个用于生成数据的函数（例如 <a href="https://www.erlang.org/doc/apps/stdlib/io_lib#format/2" target="_blank" rel="noopener noreferrer"><code>io_lib:format/2</code></a>）。</p><p><code>Args</code>是要传递给函数的参数列表。该函数用于按照指定的<code>Encoding</code>生成数据。I/O 服务器将调用该函数为： <a href="https://www.erlang.org/doc/apps/erts/erlang#apply/3" target="_blank" rel="noopener noreferrer"><code>apply(Mod, Func, Args)</code></a> 并将返回的数据作为如果是在 <code>{put_chars, Encoding, Characters}</code> 请求中发送的数据一样写入 I/O 设备。如果函数返回的不是二进制数据或列表，或者抛出异常，则需要将错误信息返回给客户端。</p></li></ul><p>I/O 服务器将一个<code>io_reply</code>元组回复给客户端，其中<code>Reply</code>是其中之一： <code>Reply</code>是其中之一：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>ok</span></span>
<span class="line"><span>{error, Error}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>错误</code>将错误信息描述给客户端，客户端可以根据需要对其进行任何操作。<a href="https://www.erlang.org/doc/apps/stdlib/io" target="_blank" rel="noopener noreferrer"><code>io</code></a>模块通常原样返回它。</li></ul><h2 id="输入请求" tabindex="-1"><a class="header-anchor" href="#输入请求"><span>输入请求</span></a></h2><p>从 I/O 设备读取字符时，存在以下<code>Request</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{get_until, Encoding, Prompt, Module, Function, ExtraArgs}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p><code>Encoding</code>表示数据将如何返回给客户端以及将数据发送给由<code>Module</code>/<code>Function</code>/<code>ExtraArgs</code>指定的函数。如果提供的函数返回数据为列表形式，数据将被转换为这种编码。如果提供的函数返回数据以某种其他格式，则无法进行转换，此时由客户端提供的函数负责以适当的方式返回数据。</p><p>如果<code>Encoding</code>为<code>latin1</code>，则当可能时，将整数列表<code>0..255</code>或包含普通字节的二进制数据返回给客户端。如果<code>Encoding</code>为 <code>unicode</code>，包含整数形式的整个 Unicode 范围内的列表或 UTF-8 编码的二进制数据，将发送给客户端。用户提供的函数总是看到整数列表，而不是二进制数据，但列表可以包含大于 255 的数字&gt; 用户提供的函数总是看到整数列表，而不是二进制数据，但列表可以包含大于 255 的数字&gt; 用户提供的函数总是看到整数列表，而不是二进制数据，但列表可以包含大于 255 的数字&gt; 编码是 unicode。</p></li><li><p>提示（Prompt）是一个字符列表（不是混合类型，没有二进制数据）或一个原子，用于在 I/O 设备上作为输入提示输出。提示（Prompt）通常会被 I/O 服务器忽略；如果设置为（&#39;&#39;），则总是会被忽略（结果是没有任何内容被写入 I/O 设备）。</p></li><li><p>模块（Module）、函数（Function）和额外参数（ExtraArgs）表示一个函数和参数，用于确定何时写入足够多的数据。该函数需要接受两个额外参数，最后一个状态和一个字符列表。该函数需要返回以下之一：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{done, Result, RestChars}</span></span>
<span class="line"><span>{more, Continuation}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>结果可以是任何 Erlang 术语，但如果它是<a href="https://www.erlang.org/doc/apps/erts/erlang#t:list/0" target="_blank" rel="noopener noreferrer"><code>list/0</code></a>，I/O 服务器可以在返回给客户端之前将其转换为<a href="https://www.erlang.org/doc/apps/erts/erlang#t:binary/0" target="_blank" rel="noopener noreferrer"><code>binary/0</code></a>（如果 I/O 服务器设置为二进制模式，请参见下文）。</p><p>该函数将 I/O 服务器在其 I/O 设备上找到的数据作为参数调用，返回以下之一：</p><ul><li><code>{done, Result, RestChars}</code> 当读取到足够多的数据时。在这种情况下 <code>Result</code> 文本发送给客户端，并且<code>RestChars</code>保留在 I/O 服务器中作为缓冲区，以便后续输入。</li><li><code>{more, 继续}</code>，这表示还需要更多字符以完成请求。</li></ul><p><code>Continuation</code> 在后续函数调用中有更多字符可用时作为状态发送。当没有更多字符可用时，函数必须返回 <code>{done, eof, Rest}</code>。初始状态是空列表。当在 IO 设备上达到文件结束时，数据为原子 <code>eof</code>。</p><p>可以使用以下函数（虽然效率不高）来模拟 <code>get_line</code> 请求：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-module(demo).</span></span>
<span class="line"><span>-export([until_newline/3, get_line/1]).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>until_newline(_ThisFar,eof,_MyStopCharacter) -&gt;</span></span>
<span class="line"><span>    {done,eof,[]};</span></span>
<span class="line"><span>until_newline(ThisFar,CharList,MyStopCharacter) -&gt;</span></span>
<span class="line"><span>    case</span></span>
<span class="line"><span>        lists:splitwith(fun(X) -&gt; X =/= MyStopCharacter end,  CharList)</span></span>
<span class="line"><span>    of</span></span>
<span class="line"><span>  {L,[]} -&gt;</span></span>
<span class="line"><span>            {more,ThisFar++L};</span></span>
<span class="line"><span>  {L2,[MyStopCharacter|Rest]} -&gt;</span></span>
<span class="line"><span>      {done,ThisFar++L2++[MyStopCharacter],Rest}</span></span>
<span class="line"><span>    end.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>get_line(IoServer) -&gt;</span></span>
<span class="line"><span>    IoServer ! {io_request,</span></span>
<span class="line"><span>                self(),</span></span>
<span class="line"><span>                IoServer,</span></span>
<span class="line"><span>                {get_until, unicode, &#39;&#39;, ?MODULE, until_newline, [$\\n]}},</span></span>
<span class="line"><span>    receive</span></span>
<span class="line"><span>        {io_reply, IoServer, Data} -&gt;</span></span>
<span class="line"><span>      Data</span></span>
<span class="line"><span>    end.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，在<code>Request</code>元组中最后一个元素（<code>[$\\n]</code>）会在函数被调用时添加到参数列表中。该函数将通过 I/O 服务器以<a href="https://www.erlang.org/doc/apps/erts/erlang#apply/3" target="_blank" rel="noopener noreferrer"><code>apply(Module, Function, [ State, Data | ExtraArgs \\])</code></a>的形式被调用。</p></li></ul><p>请求固定数量的字符使用以下的<code>Request</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{get_chars, Encoding, Prompt, N}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>编码和提示与<code>get_until</code>相同。</li><li><code>N</code>是从 I/O 设备读取的字符数。</li></ul><p>以下是一个请求单行（如前例所示）的<code>Request</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{get_line, Encoding, Prompt}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>编码和提示与<code>get_until</code>相同。</li></ul><p>显然，<code>get_chars</code> 和 <code>get_line</code> 可以用 <code>get_until</code> 请求来实现（事实上它们最初就是这样实现的），但出于效率的需求，这些扩展变得必要了。 显然，<code>get_chars</code> 和 <code>get_line</code> 可以用 <code>get_until</code> 请求来实现（事实上它们最初就是这样实现的），但出于效率的需求，这些扩展变得必要了。 显然，<code>get_chars</code> 和 <code>get_line</code> 可以用 <code>get_until</code> 请求来实现（事实上它们最初就是这样实现的），但出于效率的需求，这些扩展变得必要了。</p><p>I/O 服务器将一个<code>io_reply</code>元组回复给客户端，其中<code>Reply</code>是其中之一： <code>Reply</code>是其中之一：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Data</span></span>
<span class="line"><span>eof</span></span>
<span class="line"><span>{error, Error}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>数据</code>是以列表或二进制形式读取的字符（具体取决于 I/O 服务器模式，请参见下一节）。</li><li><code>eof</code> 在输入结束且没有更多数据可供客户端进程使用时返回。</li><li><code>错误</code>将错误信息描述给客户端，客户端可以根据需要对其进行任何处理。<a href="https://www.erlang.org/doc/apps/stdlib/io" target="_blank" rel="noopener noreferrer"><code>io</code></a>模块通常原样返回它。</li></ul><h2 id="i-o-服务器模式" tabindex="-1"><a class="header-anchor" href="#i-o-服务器模式"><span>I/O 服务器模式</span></a></h2><p>对从 I/O 服务器读取数据时效率的需求不仅导致了<code>get_line</code>和<code>get_chars</code>请求的增加，还引入了 I/O 服务器选项的概念。虽然不是强制性的，但 Erlang 标准库中的所有 I/O 服务器都实现了<code>binary</code>选项，这使得<code>io_reply</code>元组中的<code>Data</code>可以是二进制而不是列表。 <em>如果可能的话</em>，当数据以二进制形式发送时，Unicode 数据将以标准的 Erlang Unicode 格式发送，即 UTF-8（请注意，函数的 作用是） get_until 请求仍然会获取列表数据，无论 I/O 服务器模式如何。</p><p>请注意，get_until 请求允许使用一个函数，其中数据始终是列表。此外，此类请求的返回值数据也是。 列表。 函数可以是任何类型（正如当向 I/O 服务器发送请求时的情况一样） <a href="https://www.erlang.org/doc/apps/stdlib/io#fread/2" target="_blank" rel="noopener noreferrer"><code>io:fread/2,3</code></a> 请求被发送到 I/O 服务器时，客户端必须准备好接收作为这些请求答案的数据以各种形式出现。然而，I/O 服务器应在可能的情况下将结果转换为二进制数据（即，当传递给<code>get_until</code>的函数返回列表时）。 这在章节中的示例中已经完成。 <a href="https://www.erlang.org/doc/apps/stdlib/io_protocol#example_io_server" target="_blank" rel="noopener noreferrer">一个注释和工作的 I/O 服务器示例</a>.</p><p>二进制模式的 I/O 服务器会影响发送给客户端的数据，因此它必须能够处理二进制数据。为了方便，I/O 服务器的模式可以通过以下 I/O 请求设置和获取：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{setopts, Opts}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>Opts</code> 是一个选项列表，格式为 <a href="https://www.erlang.org/doc/apps/stdlib/proplists" target="_blank" rel="noopener noreferrer"><code>proplists</code></a> 所识别的格式 模块（以及输入输出服务器）。</li></ul><p>例如，交互式 shell 的输入输出服务器（在 <code>group.erl</code> 中）理解以下选项：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{binary, boolean()} (or binary/list)</span></span>
<span class="line"><span>{echo, boolean()}</span></span>
<span class="line"><span>{expand_fun, fun()}</span></span>
<span class="line"><span>{encoding, unicode/latin1} (or unicode/latin1)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>选项 <code>binary</code> 和 <code>encoding</code> 对于 OTP 中的所有输入输出服务器都是通用的，而 <code>echo</code> 和 <code>expand</code> 只对这个 I/O 服务器有效。选项 <code>unicode</code> 通知如何将字符输出到物理 I/O 设备，也就是说，终端本身是否是 Unicode 意识到的。这不影响字符发送的方式。 通知如何将字符输出到物理 I/O 设备，也就是说，终端本身是否是 Unicode 意识到的。这不影响字符发送的方式。 通知如何将字符输出到物理 I/O 设备，也就是说，终端本身是否是 Unicode 意识到的。这不影响字符发送的方式。 输入协议，其中每个请求包含编码信息，用于提供的或返回的数据。 数据。</p><p>I/O 服务器将发送以下之一作为 <code>Reply</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>ok</span></span>
<span class="line"><span>{error, Error}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果该选项不被 I/O 服务器支持（例如，在向普通文件发送一个<code>setopts</code>请求时包含一个<code>echo</code>选项），则预期会收到一个错误（最好是<code>enotsup</code>）。</p><p>要获取选项，使用了如下请求：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>getopts</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此请求要求提供所有受支持的 I/O 服务器选项的完整列表以及它们当前的值。</p><p>I/O 服务器回复：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>OptList</span></span>
<span class="line"><span>{error, Error}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>OptList</code> 是一个由元组 <code>{Option, Value}</code> 组成的列表，其中 <code>Option</code> 总是一个原子。</li></ul><h3 id="多个-i-o-请求" tabindex="-1"><a class="header-anchor" href="#多个-i-o-请求"><span>多个 I/O 请求</span></a></h3><p>The <code>Request</code> 元素本身可以包含许多 <code>Request</code>，通过使用以下格式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{requests, Requests}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>Requests</code> 是协议的有效 <code>io_request</code> 元组列表。这些元组必须按照列表中出现的顺序执行。执行将继续进行，直到其中一个请求导致错误或列表被完全消费。最后一个请求的结果将发送回客户端。</li></ul><p>I/O 服务器可以根据请求列表，在回复中发送以下任何有效结果，具体取决于请求列表中的请求：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>ok</span></span>
<span class="line"><span>{ok, Data}</span></span>
<span class="line"><span>{ok, Options}</span></span>
<span class="line"><span>{error, Error}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="可选-i-o-请求" tabindex="-1"><a class="header-anchor" href="#可选-i-o-请求"><span>可选 I/O 请求</span></a></h3><p>以下的 I/O 请求是可选实现的，客户端应准备好处理错误返回：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{get_geometry, Geometry}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>Geometry</code> 是原子 <code>rows</code> 或原子 <code>columns</code>。</li></ul><p>I/O 服务器将发送以下之一作为 <code>Reply</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>N</span></span>
<span class="line"><span>{error, Error}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>N</code> 是 I/O 设备的字符行数或列数，如果 适用于由 I/O 服务器处理的 I/O 设备，否则 <code>{error, enotsup}</code> 是一个不错的选择。</li></ul><h3 id="未实现的请求类型" tabindex="-1"><a class="header-anchor" href="#未实现的请求类型"><span>未实现的请求类型</span></a></h3><p>如果 I/O 服务器遇到一个它不认识的请求（即，<code>io_request</code>元组具有预期的格式，但<code>Request</code>未知），I/O 服务器应发送一个有效的带有错误元组的回复： 这使得可以扩展协议以包含可选请求，并且客户端可以部分兼容。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>{error, request}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这使得可以扩展协议以包含可选请求，并且客户端可以部分兼容。</p><h2 id="带注释且可运行的示例-i-o-服务器" tabindex="-1"><a class="header-anchor" href="#带注释且可运行的示例-i-o-服务器"><span>带注释且可运行的示例 I/O 服务器</span></a></h2><p>任何能够处理 I/O 协议的进程都可以称为 I/O 服务器。虽然没有通用的 I/O 服务器行为，但也可以有。框架很简单，一个处理传入请求的进程，通常包括 I/O 请求和其他特定于 I/O 设备的请求（如定位、关闭等）。</p><p>该 I/O 服务器示例将字符存储在 ETS 表中，构成一个相当粗糙的 RAM 文件。</p><p>该模块以通常的指令开始，一个启动 I/O 服务器的函数和一个处理请求的主循环：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>-module(ets_io_server).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-export([start_link/0, init/0, loop/1, until_newline/3, until_enough/3]).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-define(CHARS_PER_REC, 10).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>-record(state, {</span></span>
<span class="line"><span>	  table,</span></span>
<span class="line"><span>	  position, % absolute</span></span>
<span class="line"><span>	  mode % binary | list</span></span>
<span class="line"><span>	 }).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>start_link() -&gt;</span></span>
<span class="line"><span>    spawn_link(?MODULE,init,[]).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>init() -&gt;</span></span>
<span class="line"><span>    Table = ets:new(noname,[ordered_set]),</span></span>
<span class="line"><span>    ?MODULE:loop(#state{table = Table, position = 0, mode=list}).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>loop(State) -&gt;</span></span>
<span class="line"><span>    receive</span></span>
<span class="line"><span>	{io_request, From, ReplyAs, Request} -&gt;</span></span>
<span class="line"><span>	    case request(Request,State) of</span></span>
<span class="line"><span>		{Tag, Reply, NewState} when Tag =:= ok; Tag =:= error -&gt;</span></span>
<span class="line"><span>		    reply(From, ReplyAs, Reply),</span></span>
<span class="line"><span>		    ?MODULE:loop(NewState);</span></span>
<span class="line"><span>		{stop, Reply, _NewState} -&gt;</span></span>
<span class="line"><span>		    reply(From, ReplyAs, Reply),</span></span>
<span class="line"><span>		    exit(Reply)</span></span>
<span class="line"><span>	    end;</span></span>
<span class="line"><span>	%% Private message</span></span>
<span class="line"><span>	{From, rewind} -&gt;</span></span>
<span class="line"><span>	    From ! {self(), ok},</span></span>
<span class="line"><span>	    ?MODULE:loop(State#state{position = 0});</span></span>
<span class="line"><span>	_Unknown -&gt;</span></span>
<span class="line"><span>	    ?MODULE:loop(State)</span></span>
<span class="line"><span>    end.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主循环从客户端接收消息（客户端可以使用<code>io</code>模块发送请求）。对于每个请求，会调用<code>request/2</code>函数，并最终使用<code>reply/3</code>函数发送回复。 对于每个请求，会调用<code>request/2</code>函数，并最终使用<code>reply/3</code>函数发送回复。</p><p>&quot;The &#39;private&#39; 消息 <code>{From, rewind}</code> 会使伪文件中的当前位置重置为 <code>0</code>（文件的开头）。这通常是 I/O 设备特定消息不包含在 I/O 协议中的典型例子。通常将此类私有消息嵌入 <code>io_request</code> 元组中是一个糟糕的想法，因为这可能会使读者感到困惑。&quot;</p><p>首先，我们检查 reply 函数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>reply(From, ReplyAs, Reply) -&gt;</span></span>
<span class="line"><span>    From ! {io_reply, ReplyAs, Reply}.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>它将包含元素<code>io_reply</code>的元组发送回客户端，该元素与请求中接收到的<code>ReplyAs</code>相同，以及请求的结果。 如前所述，与请求的结果一起。 早先所述。</p><p>我们需要处理一些请求。首先处理写字符的请求：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>request({put_chars, Encoding, Chars}, State) -&gt;</span></span>
<span class="line"><span>    put_chars(unicode:characters_to_list(Chars,Encoding),State);</span></span>
<span class="line"><span>request({put_chars, Encoding, Module, Function, Args}, State) -&gt;</span></span>
<span class="line"><span>    try</span></span>
<span class="line"><span>	request({put_chars, Encoding, apply(Module, Function, Args)}, State)</span></span>
<span class="line"><span>    catch</span></span>
<span class="line"><span>	_:_ -&gt;</span></span>
<span class="line"><span>	    {error, {error,Function}, State}</span></span>
<span class="line"><span>    end;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编码说明了请求中的字符是如何表示的。我们希望将字符存储在 ETS 表中，因此使用函数<a href="https://www.erlang.org/doc/apps/stdlib/unicode#characters_to_list/2" target="_blank" rel="noopener noreferrer"><code>unicode:characters_to_list/2</code></a>将它们转换为列表。转换函数方便地接受编码类型<code>unicode</code>和<code>latin1</code>，因此我们可以直接使用<code>Encoding</code>。 <code>Encoding</code>直接。</p><p>当提供 <code>Module</code>、<code>Function</code> 和 <code>Arguments</code> 时，我们会应用这些参数，并将结果与直接提供数据时相同处理。</p><p>我们处理获取数据的请求：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>request({get_until, Encoding, _Prompt, M, F, As}, State) -&gt;</span></span>
<span class="line"><span>    get_until(Encoding, M, F, As, State);</span></span>
<span class="line"><span>request({get_chars, Encoding, _Prompt, N}, State) -&gt;</span></span>
<span class="line"><span>    %% To simplify the code, get_chars is implemented using get_until</span></span>
<span class="line"><span>    get_until(Encoding, ?MODULE, until_enough, [N], State);</span></span>
<span class="line"><span>request({get_line, Encoding, _Prompt}, State) -&gt;</span></span>
<span class="line"><span>    %% To simplify the code, get_line is implemented using get_until</span></span>
<span class="line"><span>    get_until(Encoding, ?MODULE, until_newline, [$\\n], State);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在这里稍微作弊了一点，几乎只实现了<code>get_until</code>，并通过内部辅助函数实现了<code>get_chars</code>和<code>get_line</code>。在生产代码中，这可能会效率低下，但这取决于不同请求的频率。在开始实现函数<code>put_chars/2</code> 和<code>get_until/5</code>之前，我们先看看剩下的少数几个请求：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>request({get_geometry,_}, State) -&gt;</span></span>
<span class="line"><span>    {error, {error,enotsup}, State};</span></span>
<span class="line"><span>request({setopts, Opts}, State) -&gt;</span></span>
<span class="line"><span>    setopts(Opts, State);</span></span>
<span class="line"><span>request(getopts, State) -&gt;</span></span>
<span class="line"><span>    getopts(State);</span></span>
<span class="line"><span>request({requests, Reqs}, State) -&gt;</span></span>
<span class="line"><span>     multi_request(Reqs, {ok, ok, State});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求 <code>get_geometry</code> 对于此 I/O 服务器没有意义，因此回复是 <code>{error, enotsup}</code>。我们处理的唯一选项是 <code>binary</code>/<code>list</code>，这是在单独的函数中完成的。</p><p>多请求标签 (<code>requests</code>) 在一个单独的循环函数中处理，该函数依次应用列表中的请求，并返回最后一个结果。</p><p><code>{error, request}</code> 如果请求未被识别，则必须返回：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>request(_Other, State) -&gt;</span></span>
<span class="line"><span>    {error, {error, request}, State}.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们处理不同的请求，首先是相对通用的多请求类型：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>multi_request([R|Rs], {ok, _Res, State}) -&gt;</span></span>
<span class="line"><span>    multi_request(Rs, request(R, State));</span></span>
<span class="line"><span>multi_request([_|_], Error) -&gt;</span></span>
<span class="line"><span>    Error;</span></span>
<span class="line"><span>multi_request([], Result) -&gt;</span></span>
<span class="line"><span>    Result.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们一次处理一个请求，直到遇到错误或列表被遍历完为止。 最后一个返回值会发送回客户端（首先返回到主循环，然后由函数发送回去）。 客户端（首先返回到主循环，然后由函数发送回去）。 <code>io_reply</code>).</p><p>请求 <code>getopts</code> 和 <code>setopts</code> 也是很容易处理的。我们只更改或读取状态记录：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>setopts(Opts0,State) -&gt;</span></span>
<span class="line"><span>    Opts = proplists:unfold(</span></span>
<span class="line"><span>	     proplists:substitute_negations(</span></span>
<span class="line"><span>	       [{list,binary}],</span></span>
<span class="line"><span>	       Opts0)),</span></span>
<span class="line"><span>    case check_valid_opts(Opts) of</span></span>
<span class="line"><span>	true -&gt;</span></span>
<span class="line"><span>	        case proplists:get_value(binary, Opts) of</span></span>
<span class="line"><span>		    true -&gt;</span></span>
<span class="line"><span>			{ok,ok,State#state{mode=binary}};</span></span>
<span class="line"><span>		    false -&gt;</span></span>
<span class="line"><span>			{ok,ok,State#state{mode=binary}};</span></span>
<span class="line"><span>		    _ -&gt;</span></span>
<span class="line"><span>			{ok,ok,State}</span></span>
<span class="line"><span>		end;</span></span>
<span class="line"><span>	false -&gt;</span></span>
<span class="line"><span>	    {error,{error,enotsup},State}</span></span>
<span class="line"><span>    end.</span></span>
<span class="line"><span>check_valid_opts([]) -&gt;</span></span>
<span class="line"><span>    true;</span></span>
<span class="line"><span>check_valid_opts([{binary,Bool}|T]) when is_boolean(Bool) -&gt;</span></span>
<span class="line"><span>    check_valid_opts(T);</span></span>
<span class="line"><span>check_valid_opts(_) -&gt;</span></span>
<span class="line"><span>    false.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>getopts(#state{mode=M} = S) -&gt;</span></span>
<span class="line"><span>    {ok,[{binary, case M of</span></span>
<span class="line"><span>		      binary -&gt;</span></span>
<span class="line"><span>			  true;</span></span>
<span class="line"><span>		      _ -&gt;</span></span>
<span class="line"><span>			  false</span></span>
<span class="line"><span>		  end}],S}.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作为惯例，所有的 I/O 服务器都会处理 <code>{setopts, [binary]}</code>， <code>{setopts, [list]}</code>，以及 <code>{setopts,[{binary, boolean()}]}</code> ，因此使用了 <code>proplists:substitute_negations/2</code> 和 <a href="https://www.erlang.org/doc/apps/stdlib/proplists#unfold/1" target="_blank" rel="noopener noreferrer"><code>proplists:unfold/1</code></a>。如果发送给我们的选项无效，我们将返回 <code>{error, enotsup}</code> 给客户端。 作为惯例，所有的 I/O 服务器都会处理 <code>{setopts, [binary]}</code>，<code>{setopts, [list]}</code>，以及 <code>{setopts,[{binary, boolean()}]}</code> ，因此使用了 <code>proplists:substitute_negations/2</code> 和 <a href="https://www.erlang.org/doc/apps/stdlib/proplists#unfold/1" target="_blank" rel="noopener noreferrer"><code>proplists:unfold/1</code></a>。如果发送给我们的选项无效，我们将返回 <code>{error, enotsup}</code> 给客户端。</p><p>请求 <code>getopts</code> 用于返回一个 <code>{Option, Value}</code> 元组列表。这双重功能既提供了当前值，也提供了此 I/O 服务器的可用选项。我们只有一个选项，因此返回该选项。</p><p>目前这个 I/O 服务器相当通用（除了在主循环中处理的<code>rewind</code>请求以及创建 ETS 表外）。大多数 I/O 服务器包含类似以下的代码。</p><p>为了使示例可运行，我们开始实现数据与 ETS 表之间的读写操作。首先函数<code>put_chars/3</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>put_chars(Chars, #state{table = T, position = P} = State) -&gt;</span></span>
<span class="line"><span>    R = P div ?CHARS_PER_REC,</span></span>
<span class="line"><span>    C = P rem ?CHARS_PER_REC,</span></span>
<span class="line"><span>    [ apply_update(T,U) || U &lt;- split_data(Chars, R, C) ],</span></span>
<span class="line"><span>    {ok, ok, State#state{position = (P + length(Chars))}}.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们已经将数据作为 Unicode 列表获取，因此只需按预定义的大小将列表分割成段，并将每段放在当前位置的表格中（并向前移动）。函数<code>split_data/3</code>和<code>apply_update/2</code>的实现如下。</p><p>现在我们想要从表中读取数据。函数 <code>get_until/5</code> 会读取数据并在完成时应用函数。结果会发送回客户端：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>get_until(Encoding, Mod, Func, As,</span></span>
<span class="line"><span>	  #state{position = P, mode = M, table = T} = State) -&gt;</span></span>
<span class="line"><span>    case get_loop(Mod,Func,As,T,P,[]) of</span></span>
<span class="line"><span>	{done,Data,_,NewP} when is_binary(Data); is_list(Data) -&gt;</span></span>
<span class="line"><span>	    if</span></span>
<span class="line"><span>		M =:= binary -&gt;</span></span>
<span class="line"><span>		    {ok,</span></span>
<span class="line"><span>		     unicode:characters_to_binary(Data, unicode, Encoding),</span></span>
<span class="line"><span>		     State#state{position = NewP}};</span></span>
<span class="line"><span>		true -&gt;</span></span>
<span class="line"><span>		    case check(Encoding,</span></span>
<span class="line"><span>		               unicode:characters_to_list(Data, unicode))</span></span>
<span class="line"><span>                    of</span></span>
<span class="line"><span>			{error, _} = E -&gt;</span></span>
<span class="line"><span>			    {error, E, State};</span></span>
<span class="line"><span>			List -&gt;</span></span>
<span class="line"><span>			    {ok, List,</span></span>
<span class="line"><span>			     State#state{position = NewP}}</span></span>
<span class="line"><span>		    end</span></span>
<span class="line"><span>	    end;</span></span>
<span class="line"><span>	{done,Data,_,NewP} -&gt;</span></span>
<span class="line"><span>	    {ok, Data, State#state{position = NewP}};</span></span>
<span class="line"><span>	Error -&gt;</span></span>
<span class="line"><span>	    {error, Error, State}</span></span>
<span class="line"><span>    end.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>get_loop(M,F,A,T,P,C) -&gt;</span></span>
<span class="line"><span>    {NewP,L} = get(P,T),</span></span>
<span class="line"><span>    case catch apply(M,F,[C,L|A]) of</span></span>
<span class="line"><span>	{done, List, Rest} -&gt;</span></span>
<span class="line"><span>	    {done, List, [], NewP - length(Rest)};</span></span>
<span class="line"><span>	{more, NewC} -&gt;</span></span>
<span class="line"><span>	    get_loop(M,F,A,T,NewP,NewC);</span></span>
<span class="line"><span>	_ -&gt;</span></span>
<span class="line"><span>	    {error,F}</span></span>
<span class="line"><span>    end.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里我们还处理由请求设置的模式（<code>二进制</code> 或 <code>列表</code>）。通过 <code>setopts</code> 可以设置模式。默认情况下，所有 OTP I/O 服务器将数据发送回客户端以列表形式，但如果 I/O 服务器以适当的方式处理，切换模式到 <code>二进制</code> 可以提高效率。<code>get_until</code> 的实现很难高效，因为提供的函数定义为接受列表作为参数，但 <code>get_chars</code> 和 <code>get_line</code> 可以针对二进制模式进行优化。然而，这个例子并没有进行任何优化。 <code>setopts</code>. By default, all OTP I/O servers send data back to the client as lists, but switching mode to <code>binary</code> can increase efficiency if the I/O server handles it in an appropriate way. The implementation of <code>get_until</code> is difficult to get efficient, as the supplied function is defined to take lists as arguments, but <code>get_chars</code> and <code>get_line</code> can be optimized for binary mode. However, this example does not optimize anything.</p><p>然而，返回的数据类型必须根据设置的选项正确。因此，在可能的情况下，我们在返回之前会将列表转换为正确的编码的二进制数据。在“get_until”请求元组中提供的函数可以返回任何内容，因此只有返回列表的函数才能将它们转换为二进制数据。如果请求包含编码标签“unicode”，列表可以包含所有 Unicode 码点，二进制数据应为 UTF-8。如果编码标签是“latin1”，客户端只能获取范围在 0..255 之间的字符。函数“check/2”会确保如果编码指定为“latin1”，列表中不会返回任意的 Unicode 码点。如果函数不返回列表，检查将无法进行，结果将保持为提供的函数返回的原始结果。 在“get_until”请求元组中的提供的函数可以作为其最终结果返回任何内容，因此只有返回列表的函数才能将它们转换为二进制数据。如果请求包含编码标签“unicode”，列表可以包含所有 Unicode 码点，二进制数据应为 UTF-8。如果编码标签是“latin1”，客户端只能获取范围在 0..255 之间的字符。函数“check/2”会确保如果编码指定为“latin1”，列表中不会返回任意的 Unicode 码点。如果函数不返回列表，检查将无法进行，结果将保持为提供的函数返回的原始结果。</p><p>为了操作表格，我们实现了以下辅助函数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>check(unicode, List) -&gt;</span></span>
<span class="line"><span>    List;</span></span>
<span class="line"><span>check(latin1, List) -&gt;</span></span>
<span class="line"><span>    try</span></span>
<span class="line"><span>	[ throw(not_unicode) || X &lt;- List,</span></span>
<span class="line"><span>				X &gt; 255 ],</span></span>
<span class="line"><span>	List</span></span>
<span class="line"><span>    catch</span></span>
<span class="line"><span>	throw:_ -&gt;</span></span>
<span class="line"><span>	    {error,{cannot_convert, unicode, latin1}}</span></span>
<span class="line"><span>    end.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>check 函数如果客户端请求了 <code>latin1</code>，并且需要返回 Unicode 字符点大于 255 的情况，将提供一个错误元组。</p><p>两个函数 <code>until_newline/3</code> 和 <code>until_enough/3</code> 是用于与函数 <code>get_until/5</code> 一起实现 <code>get_chars</code> 和 <code>get_line</code> 的辅助函数 (低效地)：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>until_newline([],eof,_MyStopCharacter) -&gt;</span></span>
<span class="line"><span>    {done,eof,[]};</span></span>
<span class="line"><span>until_newline(ThisFar,eof,_MyStopCharacter) -&gt;</span></span>
<span class="line"><span>    {done,ThisFar,[]};</span></span>
<span class="line"><span>until_newline(ThisFar,CharList,MyStopCharacter) -&gt;</span></span>
<span class="line"><span>    case</span></span>
<span class="line"><span>        lists:splitwith(fun(X) -&gt; X =/= MyStopCharacter end,  CharList)</span></span>
<span class="line"><span>    of</span></span>
<span class="line"><span>	{L,[]} -&gt;</span></span>
<span class="line"><span>            {more,ThisFar++L};</span></span>
<span class="line"><span>	{L2,[MyStopCharacter|Rest]} -&gt;</span></span>
<span class="line"><span>	    {done,ThisFar++L2++[MyStopCharacter],Rest}</span></span>
<span class="line"><span>    end.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>until_enough([],eof,_N) -&gt;</span></span>
<span class="line"><span>    {done,eof,[]};</span></span>
<span class="line"><span>until_enough(ThisFar,eof,_N) -&gt;</span></span>
<span class="line"><span>    {done,ThisFar,[]};</span></span>
<span class="line"><span>until_enough(ThisFar,CharList,N)</span></span>
<span class="line"><span>  when length(ThisFar) + length(CharList) &gt;= N -&gt;</span></span>
<span class="line"><span>    {Res,Rest} = my_split(N,ThisFar ++ CharList, []),</span></span>
<span class="line"><span>    {done,Res,Rest};</span></span>
<span class="line"><span>until_enough(ThisFar,CharList,_N) -&gt;</span></span>
<span class="line"><span>    {more,ThisFar++CharList}.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如您所见，上述函数正是在<code>get_until</code>请求中需要提供的函数类型。</p><p>为了完成 I/O 服务器，我们只需要以适当的方式读取和写入表格：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>get(P,Tab) -&gt;</span></span>
<span class="line"><span>    R = P div ?CHARS_PER_REC,</span></span>
<span class="line"><span>    C = P rem ?CHARS_PER_REC,</span></span>
<span class="line"><span>    case ets:lookup(Tab,R) of</span></span>
<span class="line"><span>	[] -&gt;</span></span>
<span class="line"><span>	    {P,eof};</span></span>
<span class="line"><span>	[{R,List}] -&gt;</span></span>
<span class="line"><span>	    case my_split(C,List,[]) of</span></span>
<span class="line"><span>		{_,[]} -&gt;</span></span>
<span class="line"><span>		    {P+length(List),eof};</span></span>
<span class="line"><span>		{_,Data} -&gt;</span></span>
<span class="line"><span>		    {P+length(Data),Data}</span></span>
<span class="line"><span>	    end</span></span>
<span class="line"><span>    end.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>my_split(0,Left,Acc) -&gt;</span></span>
<span class="line"><span>    {lists:reverse(Acc),Left};</span></span>
<span class="line"><span>my_split(_,[],Acc) -&gt;</span></span>
<span class="line"><span>    {lists:reverse(Acc),[]};</span></span>
<span class="line"><span>my_split(N,[H|T],Acc) -&gt;</span></span>
<span class="line"><span>    my_split(N-1,T,[H|Acc]).</span></span>
<span class="line"><span></span></span>
<span class="line"><span>split_data([],_,_) -&gt;</span></span>
<span class="line"><span>    [];</span></span>
<span class="line"><span>split_data(Chars, Row, Col) -&gt;</span></span>
<span class="line"><span>    {This,Left} = my_split(?CHARS_PER_REC - Col, Chars, []),</span></span>
<span class="line"><span>    [ {Row, Col, This} | split_data(Left, Row + 1, 0) ].</span></span>
<span class="line"><span></span></span>
<span class="line"><span>apply_update(Table, {Row, Col, List}) -&gt;</span></span>
<span class="line"><span>    case ets:lookup(Table,Row) of</span></span>
<span class="line"><span>	[] -&gt;</span></span>
<span class="line"><span>	    ets:insert(Table,{Row, lists:duplicate(Col,0) ++ List});</span></span>
<span class="line"><span>	[{Row, OldData}] -&gt;</span></span>
<span class="line"><span>	    {Part1,_} = my_split(Col,OldData,[]),</span></span>
<span class="line"><span>	    {_,Part2} = my_split(Col+length(List),OldData,[]),</span></span>
<span class="line"><span>	    ets:insert(Table,{Row, Part1 ++ List ++ Part2})</span></span>
<span class="line"><span>    end.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该表以 <code>?CHARS_PER_REC</code> 的块进行读取或写入，必要时会覆盖原有内容。实现显然不够高效，但它只是能够工作。</p><p>这个示例到此结束。你可以使用 <a href="https://www.erlang.org/doc/apps/stdlib/io" target="_blank" rel="noopener noreferrer"><code>io</code></a> 模块或甚至是 <a href="https://www.erlang.org/doc/apps/kernel/file" target="_blank" rel="noopener noreferrer"><code>file</code></a> 模块与 I/O 服务器进行读写操作。实现一个完整的 I/O 服务器就这么简单。 在 Erlang 中。 完全轻而易举。</p>`,114)]))}const c=e(l,[["render",d]]),r=JSON.parse('{"path":"/backend/erlang/g9gnmbh5/","title":"输入协议","lang":"zh-CN","frontmatter":{"title":"输入协议","createTime":"2025/03/23 14:39:28","permalink":"/backend/erlang/g9gnmbh5/"},"headers":[],"readingTime":{"minutes":21.22,"words":6367},"git":{"updatedTime":1743091220000,"contributors":[{"name":"舒永好","username":"舒永好","email":"shuyonghao@guoshenghuaxing.com","commits":1,"avatar":"https://gravatar.com/avatar/4b1c3f37ea707968be73c631a79de33afd360724ce87bf8f9dcacd67d14df92c?d=retro"}]},"filePathRelative":"notes/backend/erlang/erlang_core/stdlib/input_contact.md"}');export{c as comp,r as data};
